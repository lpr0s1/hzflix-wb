<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>SpaceGame Mobile 3D Vaisseau Réel</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<style>
html, body { margin:0; padding:0; width:100%; height:100%; background:black; -webkit-user-select:none; user-select:none; }
canvas { display:block; }
#loader { position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; background:black; color:#fff; font-family:sans-serif; font-size:20px; z-index:1000; }
#loader-ok { margin-top:12px; font-size:28px; color:#0f0; opacity:0; transition:opacity 0.4s ease-in-out; }
.joystick { position:absolute; bottom:20px; left:20px; width:100px; height:100px; border-radius:50%; background:rgba(255,255,255,0.08); touch-action:none; -webkit-tap-highlight-color: transparent; }
.joystick-inner { position:absolute; width:50px; height:50px; border-radius:50%; background:rgba(255,255,255,0.22); top:25px; left:25px; pointer-events:none; transform:translate(0,0); transition:transform 0.05s linear; }
.btn { position:absolute; width:60px; height:60px; border-radius:50%; background:rgba(255,255,255,0.12); text-align:center; line-height:60px; font-weight:bold; color:white; touch-action:none; -webkit-user-select:none; user-select:none; }
.btn.up { bottom:100px; right:20px; }
.btn.down { bottom:20px; right:20px; }
</style>
</head>
<body>
<div id="loader">Chargement des ressources...<div id="loader-ok">✔ OK</div></div>
<div class="joystick" id="joystick"><div class="joystick-inner" id="joyInner"></div></div>
<div class="btn up" id="btnUp">↑</div>
<div class="btn down" id="btnDown">↓</div>

<!-- Utilisation d'ES modules pour Three.js et GLTFLoader -->
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';

(async function(){
try {
    const loaderDiv = document.getElementById('loader');
    const okDiv = document.getElementById('loader-ok');

    // Scene, camera, renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000010);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.set(0,5,15);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lumières
    const ambient = new THREE.AmbientLight(0x666666); scene.add(ambient);
    const sunLight = new THREE.PointLight(0xffffff, 2, 0, 2); sunLight.position.set(0,0,0); scene.add(sunLight);
    const sun = new THREE.Mesh(new THREE.SphereGeometry(8,32,32), new THREE.MeshBasicMaterial({color:0xffffcc})); scene.add(sun);

    // Textures (chargement asynchrone)
    const texLoader = new THREE.TextureLoader();
    const earthTex = await texLoader.loadAsync('https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg');
    const earthSpec = await texLoader.loadAsync('https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg');
    const earthNorm = await texLoader.loadAsync('https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_normal_2048.jpg');
    const cloudsTex = await texLoader.loadAsync('https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png');
    const moonTex = await texLoader.loadAsync('https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg');

    // Terre + nuages + lune
    const earthMat = new THREE.MeshPhongMaterial({map:earthTex, specularMap:earthSpec, normalMap:earthNorm, shininess:5});
    const earth = new THREE.Mesh(new THREE.SphereGeometry(5,64,64), earthMat);
    earth.position.set(50,0,0); scene.add(earth);

    const cloudsMat = new THREE.MeshPhongMaterial({map:cloudsTex, transparent:true, depthWrite:false, opacity:0.9});
    const clouds = new THREE.Mesh(new THREE.SphereGeometry(5.05,64,64), cloudsMat); earth.add(clouds);

    const moon = new THREE.Mesh(new THREE.SphereGeometry(1.3,32,32), new THREE.MeshPhongMaterial({map:moonTex}));
    moon.position.set(8,0,0); earth.add(moon);

    // Étoiles
    const starGeom = new THREE.BufferGeometry();
    const starCount = 2000;
    const positions = new Float32Array(starCount*3);
    for(let i=0;i<starCount;i++){
        positions[i*3] = (Math.random()-0.5)*2000;
        positions[i*3+1] = (Math.random()-0.5)*2000;
        positions[i*3+2] = (Math.random()-0.5)*2000;
    }
    starGeom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    const stars = new THREE.Points(starGeom, new THREE.PointsMaterial({color:0x99ddff, size:1.5, sizeAttenuation:true, transparent:true, opacity:0.9}));
    scene.add(stars);

    // Chargement du vaisseau 3D public (glTF)
    // Exemple de modèle public : "DamagedHelmet" ou "CesiumMan" (ici on utilise CesiumMan glb)
    const shipUrl = 'https://rawcdn.githack.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMan/glTF-Binary/CesiumMan.glb';
    const gltfLoader = new GLTFLoader();

    let ship = null;
    try {
        const gltf = await new Promise((resolve, reject) => {
            gltfLoader.load(shipUrl, resolve, undefined, reject);
        });
        ship = gltf.scene;
        // Ajustements pour que le "vaisseau" soit orienté et de taille raisonnable
        ship.scale.set(0.6,0.6,0.6);
        ship.position.set(0,0,0);
        ship.traverse((c) => {
            if (c.isMesh) {
                c.castShadow = true;
                c.receiveShadow = true;
            }
        });
        scene.add(ship);
    } catch(e) {
        console.warn('Impossible de charger le modèle glTF, création d\'un vaisseau de secours simple.', e);
        // Si le chargement échoue, créer un vaisseau simple (géométrie) pour garantir le fonctionnement
        const fallbackMat = new THREE.MeshStandardMaterial({color:0x88ccff, metalness:0.6, roughness:0.4});
        ship = new THREE.Group();
        const body = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2.5, 16), fallbackMat);
        body.rotation.x = Math.PI / 2;
        const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 0.6), fallbackMat);
        wingL.position.set(-0.9, 0, 0);
        const wingR = wingL.clone(); wingR.position.set(0.9, 0, 0);
        ship.add(body, wingL, wingR);
        ship.position.set(0,0,0);
        scene.add(ship);
    }

    // Indicateur de chargement OK
    okDiv.style.opacity='1';
    await new Promise(r=>setTimeout(r,350));
    loaderDiv.style.display='none';

    // Contrôles tactiles / souris (joystick)
    let move = {x:0,y:0,up:false,down:false};
    const joy = document.getElementById('joystick');
    const joyInner = document.getElementById('joyInner');

    // Helper pour pointer events (touch + mouse)
    function handlePointerMove(clientX, clientY){
        const r = joy.getBoundingClientRect();
        const cx = r.left + r.width/2;
        const cy = r.top + r.height/2;
        move.x = Math.max(-1, Math.min(1, (clientX - cx) / (r.width/2)));
        move.y = Math.max(-1, Math.min(1, -(clientY - cy) / (r.height/2)));
        joyInner.style.transform = `translate(${move.x*25}px, ${-move.y*25}px)`;
    }

    // Touch events
    joy.addEventListener('touchstart', e => { e.preventDefault(); handlePointerMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    joy.addEventListener('touchmove', e => { e.preventDefault(); handlePointerMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    joy.addEventListener('touchend', e => { move.x=0; move.y=0; joyInner.style.transform='translate(0,0)'; }, {passive:false});

    // Mouse fallback for desktop
    let mouseDown = false;
    joy.addEventListener('pointerdown', e => { mouseDown = true; joy.setPointerCapture(e.pointerId); handlePointerMove(e.clientX, e.clientY); });
    window.addEventListener('pointermove', e => { if(mouseDown) handlePointerMove(e.clientX, e.clientY); });
    window.addEventListener('pointerup', e => { if(mouseDown) { mouseDown=false; move.x=0; move.y=0; joyInner.style.transform='translate(0,0)'; } });

    // Boutons haut/bas
    const btnUp = document.getElementById('btnUp');
    const btnDown = document.getElementById('btnDown');
    btnUp.addEventListener('touchstart', ()=> move.up=true, {passive:true});
    btnUp.addEventListener('touchend', ()=> move.up=false, {passive:true});
    btnDown.addEventListener('touchstart', ()=> move.down=true, {passive:true});
    btnDown.addEventListener('touchend', ()=> move.down=false, {passive:true});
    // Mouse fallback
    btnUp.addEventListener('mousedown', ()=> move.up=true);
    btnUp.addEventListener('mouseup', ()=> move.up=false);
    btnDown.addEventListener('mousedown', ()=> move.down=true);
    btnDown.addEventListener('mouseup', ()=> move.down=false);

    // Physique simple du vaisseau
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    const forward = new THREE.Vector3(0,0,-1);

    // Sécurité: si ship est null, créer un placeholder
    if(!ship){
        ship = new THREE.Mesh(new THREE.BoxGeometry(1,0.4,2), new THREE.MeshStandardMaterial({color:0x88aaff}));
        scene.add(ship);
    }

    // Animation loop
    function animate(){
        requestAnimationFrame(animate);

        // Mouvement orbital de la Terre
        const t = Date.now() * 0.00005;
        earth.position.x = 50 * Math.cos(t);
        earth.position.z = 50 * Math.sin(t);
        clouds.rotation.y += 0.0005;
        moon.rotation.y += 0.001;

        // Direction selon joystick
        direction.set(0,0,0);
        // Appliquer la rotation actuelle du vaisseau pour avancer dans sa direction locale
        const localForward = forward.clone().applyEuler(ship.rotation);
        direction.add(localForward.multiplyScalar(move.y * 0.25));
        if(move.up) direction.y += 0.12;
        if(move.down) direction.y -= 0.12;

        // Lerp pour un mouvement plus doux
        velocity.lerp(direction, 0.08);
        ship.position.add(velocity);

        // Rotation yaw selon axe X du joystick
        ship.rotation.y -= move.x * 0.04;

        // Caméra suit le vaisseau (damping)
        const desiredCamPos = ship.position.clone().add(new THREE.Vector3(0,3,8).applyEuler(ship.rotation));
        camera.position.lerp(desiredCamPos, 0.12);
        camera.lookAt(ship.position);

        renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

} catch(err) {
    // Message d'erreur clair pour debug
    console.error(err);
    alert('Erreur: ' + (err && err.message ? err.message : err));
}
})();
</script>
</body>
</html>

