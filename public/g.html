<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Space — Flat Ship, Wormholes & Black Holes</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<style>
  html,body{margin:0;height:100%;background:#000;user-select:none;overflow:hidden}
  canvas{display:block}
  #hud{position:fixed;left:16px;top:16px;color:#fff;font-family:system-ui,Arial;z-index:99;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px}
  .joystick{position:fixed;left:16px;bottom:16px;width:100px;height:100px;border-radius:50%;background:rgba(255,255,255,0.06);touch-action:none;z-index:99}
  .joystick-inner{width:50px;height:50px;border-radius:50%;background:rgba(255,255,255,0.18);position:relative;left:25px;top:25px;pointer-events:none}
  .btn{position:fixed;right:16px;width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.08);text-align:center;line-height:60px;color:#fff;z-index:99}
  .btn.up{bottom:96px}.btn.down{bottom:16px}
</style>
</head>
<body>
<div id="hud">Vitesse: <span id="speed">0</span> | Proche corps: <span id="near">—</span></div>
<div class="joystick" id="joystick"><div class="joystick-inner" id="joyInner"></div></div>
<div class="btn up" id="btnUp">↑</div>
<div class="btn down" id="btnDown">↓</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

// ---------- util loader ----------
const texLoader = new THREE.TextureLoader();
const loadSafe = url => new Promise(resolve => texLoader.load(url, t=>resolve(t), undefined, ()=>resolve(null)));

// ---------- scène / cam / renderer ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000007);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// HUD nodes
const speedEl = document.getElementById('speed');
const nearEl = document.getElementById('near');

// ---------- lights ----------
scene.add(new THREE.AmbientLight(0x666666));
const sunLight = new THREE.PointLight(0xffffff, 3.2, 0);
sunLight.position.set(0,0,0); scene.add(sunLight);

// ---------- sun ----------
const sun = new THREE.Mesh(new THREE.SphereGeometry(600, 32, 32), new THREE.MeshBasicMaterial({color:0xffee88}));
scene.add(sun);

// ---------- star sprite creation (round luminous) ----------
function createStarSprite(size=128){
  const canvas = document.createElement('canvas'); canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  const g = ctx.createRadialGradient(size/2,size/2,2,size/2,size/2,size/2);
  g.addColorStop(0,'rgba(255,255,255,1)');
  g.addColorStop(0.2,'rgba(170,200,255,0.95)');
  g.addColorStop(0.5,'rgba(120,160,255,0.45)');
  g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(canvas); tex.minFilter = THREE.LinearFilter;
  return tex;
}
const starSprite = createStarSprite();

// ---------- starfields (two layers) ----------
function makeStars(count, rMin, rMax, size){
  const geom = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const sizes = new Float32Array(count);
  for(let i=0;i<count;i++){
    const r = rMin + Math.random()*(rMax-rMin);
    const theta = Math.random()*Math.PI*2;
    const phi = (Math.random()-0.5)*Math.PI;
    pos[3*i]=Math.cos(theta)*Math.cos(phi)*r; pos[3*i+1]=Math.sin(phi)*r; pos[3*i+2]=Math.sin(theta)*Math.cos(phi)*r;
    sizes[i]=size*(0.6 + Math.random()*0.9);
  }
  geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geom.setAttribute('size', new THREE.BufferAttribute(sizes,1));
  const mat = new THREE.PointsMaterial({map:starSprite,size:size,transparent:true,opacity:0.95,depthWrite:false,blending:THREE.AdditiveBlending});
  const pts = new THREE.Points(geom, mat);
  scene.add(pts);
  return pts;
}
const farStars = makeStars(2000, 100000, 400000, 120);
const midStars = makeStars(1200, 25000, 120000, 36);

// ---------- dust ----------
(function(){
  const count = 6000, geom=new THREE.BufferGeometry(), pos=new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r=8000 + Math.random()*250000;
    const th=Math.random()*Math.PI*2, ph=(Math.random()-0.5)*0.15;
    pos[3*i]=Math.cos(th)*Math.cos(ph)*r; pos[3*i+1]=Math.sin(ph)*r; pos[3*i+2]=Math.sin(th)*Math.cos(ph)*r;
  }
  geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({size:16,transparent:true,opacity:0.06,depthWrite:false,blending:THREE.AdditiveBlending,color:0xfff7ef});
  const pts = new THREE.Points(geom, mat); scene.add(pts); window._dust=pts;
})();

// ---------- Système solaire réaliste (visuel; gameplay-scaled) ----------
/* Planètes extrêmement grandes par rapport au vaisseau.
   Distances massives pour énormément d'espace. */
const planetData = [
  // name, displayRadius, distanceFromSun, textureURL (examples), ring?
  ['Mercury', 1600, 12000, 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/mercury.jpg', false],
  ['Venus',   3800, 22000, 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/venus.jpg', false],
  ['Earth',   4200, 34000, 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg', false],
  ['Moon',    1100, 4200,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg', false], // will be parented
  ['Mars',    2100, 48000, 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/mars_1k_color.jpg', false],
  ['Jupiter', 9800, 82000, 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/jupiter.jpg', false],
  ['Saturn',  9000, 140000,'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/saturn.jpg', 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/saturnringcolor.jpg'],
  ['Uranus',  5400, 210000,'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/uranus.jpg', false],
  ['Neptune', 5200, 300000,'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/neptune.jpg', false],
  ['Pluto',   900,  380000, null, false]
];

const planets = [];
async function buildPlanets(){
  for(const p of planetData){
    const [name, rad, dist, tex, ringTex] = p;
    const texture = tex ? await loadSafe(tex) : null;
    const geo = new THREE.SphereGeometry(rad, 64, 64);
    const mat = new THREE.MeshStandardMaterial(texture?{map:texture, metalness:0.02, roughness:0.7}:{color:0x777777, metalness:0.02, roughness:0.7});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(dist, 0, 0);
    mesh.userData = { name, radius: rad, distance: dist, angle: Math.random()*Math.PI*2, orbitalSpeed: (1/(100 + Math.random()*400))*0.00002 };
    scene.add(mesh);
    if(ringTex){
      const ringTexture = await loadSafe(ringTex);
      const ringGeo = new THREE.RingGeometry(rad*1.15, rad*2.0, 128,1);
      const ringMat = new THREE.MeshBasicMaterial({map:ringTexture, side:THREE.DoubleSide, transparent:true, opacity:0.9});
      const ring = new THREE.Mesh(ringGeo, ringMat); ring.rotation.x = Math.PI/2.6; ring.position.copy(mesh.position); scene.add(ring);
      mesh.userData.ring = ring;
    }
    planets.push(mesh);
  }
  // parent Moon to Earth for correct local orbit
  const earth = planets.find(x=>x.userData.name==='Earth');
  const moon = planets.find(x=>x.userData.name==='Moon');
  if(earth && moon){
    moon.position.set(earth.userData.radius + 4500, 0, 0); // moon relative
    earth.add(moon);
    moon.userData = {orbitSpeed:0.0008, dist: earth.userData.radius + 4500, angle: 0};
  }
}
await buildPlanets();

// ---------- Ship: flat model + rear turbos, much smaller than planets ----------
function buildFlatShip(){
  const g = new THREE.Group();
  // hull — flattened diamond
  const hull = new THREE.Mesh(new THREE.BoxGeometry(240, 24, 420), new THREE.MeshStandardMaterial({color:0x8b8f91, metalness:0.9, roughness:0.2}));
  hull.scale.set(1,0.25,1);
  hull.position.set(0,0,10);
  g.add(hull);
  // cockpit
  const cockpit = new THREE.Mesh(new THREE.SphereGeometry(48, 20, 20), new THREE.MeshPhysicalMaterial({color:0x0b2a3d, transmission:0.6, transparent:true, opacity:0.92}));
  cockpit.position.set(0,24,120);
  g.add(cockpit);
  // wings thin
  const wing = new THREE.Mesh(new THREE.BoxGeometry(120,8,520), new THREE.MeshStandardMaterial({color:0x7f8487, metalness:0.85, roughness:0.18}));
  wing.position.set(0,-8,0); wing.scale.set(1,0.08,1); g.add(wing);
  // rear turbos (left/right)
  const turboMat = new THREE.MeshStandardMaterial({color:0x222222, metalness:0.95, roughness:0.12});
  const turboL = new THREE.Mesh(new THREE.CylinderGeometry(40,44,160,18), turboMat); turboL.rotation.x=Math.PI/2; turboL.position.set(-100,-36,-210);
  const turboR = turboL.clone(); turboR.position.set(100,-36,-210); g.add(turboL, turboR);
  // exhaust particle cloud
  const pCount = 160; const arr = new Float32Array(pCount*3);
  for(let i=0;i<pCount;i++){ arr[3*i]=(Math.random()-0.5)*80; arr[3*i+1]=-40 - Math.random()*40; arr[3*i+2]=-220 - Math.random()*140; }
  const pGeo = new THREE.BufferGeometry(); pGeo.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const pMat = new THREE.PointsMaterial({color:0xff8a33, size:18, transparent:true, opacity:0.9, depthWrite:false});
  const exhaust = new THREE.Points(pGeo, pMat); g.add(exhaust);
  g.userData.radius = 220; // collision radius ~220
  return g;
}
const ship = buildFlatShip();
ship.position.set(7000, 1200, 0); // start far from sun and planets
scene.add(ship);

// ---------- ship physics state ----------
const state = { pos: ship.position.clone(), vel: new THREE.Vector3(0,0,0), acc: new THREE.Vector3(0,0,0), mass: 1.0 };

// ---------- controls ----------
let move = {x:0,y:0,up:false,down:false};
const joy = document.getElementById('joystick'), joyInner = document.getElementById('joyInner');
joy.addEventListener('touchstart', e=>e.preventDefault());
joy.addEventListener('touchmove', e=>{
  const t = e.touches[0]; const r = joy.getBoundingClientRect();
  move.x = Math.max(-1, Math.min(1, (t.clientX - (r.left + r.width/2))/(r.width/2)));
  move.y = Math.max(-1, Math.min(1, -(t.clientY - (r.top + r.height/2))/(r.height/2)));
  joyInner.style.transform = `translate(${move.x*25}px, ${-move.y*25}px)`;
});
joy.addEventListener('touchend', ()=>{ move.x=0; move.y=0; joyInner.style.transform='translate(0,0)'; });
document.getElementById('btnUp').addEventListener('touchstart', ()=>move.up=true);
document.getElementById('btnUp').addEventListener('touchend', ()=>move.up=false);
document.getElementById('btnDown').addEventListener('touchstart', ()=>move.down=true);
document.getElementById('btnDown').addEventListener('touchend', ()=>move.down=false);
window.addEventListener('keydown', e=>{
  if(e.key==='w') move.y=1; if(e.key==='s') move.y=-1; if(e.key==='a') move.x=-1; if(e.key==='d') move.x=1;
  if(e.key==='ArrowUp') move.up=true; if(e.key==='ArrowDown') move.down=true;
});
window.addEventListener('keyup', e=>{
  if(['w','s'].includes(e.key)) move.y=0; if(['a','d'].includes(e.key)) move.x=0;
  if(e.key==='ArrowUp') move.up=false; if(e.key==='ArrowDown') move.down=false;
});

// ---------- wormholes (7) with distortion & star stretch ----------
const wormholes = [];
function makeWormhole(pos, size=2000){
  const torGeo = new THREE.TorusGeometry(size, size*0.18, 24, 120);
  const torMat = new THREE.MeshBasicMaterial({color:0x66ccff, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending, side:THREE.DoubleSide});
  const tor = new THREE.Mesh(torGeo, torMat); tor.position.copy(pos); scene.add(tor);
  // funnel points
  const pc = 2400; const pArr = new Float32Array(pc*3);
  for(let i=0;i<pc;i++){
    const r = Math.random()*size*0.9; const a = Math.random()*Math.PI*2; const z = (Math.random()-0.5)*size*2.4;
    pArr[3*i]=Math.cos(a)*r; pArr[3*i+1]=Math.sin(a)*r; pArr[3*i+2]=z;
  }
  const pg = new THREE.BufferGeometry(); pg.setAttribute('position', new THREE.BufferAttribute(pArr,3));
  const pm = new THREE.PointsMaterial({size:40, color:0xaaffff, transparent:true, opacity:0.9, depthWrite:false, blending:THREE.AdditiveBlending});
  const funnel = new THREE.Points(pg, pm); funnel.position.copy(pos); scene.add(funnel);
  wormholes.push({tor, funnel, pos:pos.clone(), size});
  return {tor, funnel};
}
// place them very far so space is roomy
for(let i=0;i<7;i++){
  const angle=Math.random()*Math.PI*2;
  const d = 500000 + Math.random()*600000; // very far
  const p = new THREE.Vector3(Math.cos(angle)*d, (Math.random()-0.5)*60000, Math.sin(angle)*d);
  makeWormhole(p, 10000 + Math.random()*7000);
}

// ---------- black holes (2) with 1/r^2 gravity and ejection ----------
const blackHoles = [];
function makeBlackHole(pos, mass, radius){
  const bh = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), new THREE.MeshBasicMaterial({color:0x000000}));
  bh.position.copy(pos); scene.add(bh);
  const disc = new THREE.Mesh(new THREE.RingGeometry(radius*1.6, radius*4.2, 64), new THREE.MeshBasicMaterial({color:0x552288, transparent:true, opacity:0.55, side:THREE.DoubleSide}));
  disc.rotation.x = Math.PI/2; disc.position.copy(pos); scene.add(disc);
  blackHoles.push({pos:pos.clone(), mass, radius, mesh:bh});
  return {pos, mass, radius};
}
makeBlackHole(new THREE.Vector3(-800000, 0, -360000), 2.2e10, 28000); // massive, far
makeBlackHole(new THREE.Vector3(920000, -120000, 720000), 1.6e10, 21000);

// ---------- collision: ship vs planets (prevents passing through) ----------
function resolvePlanetCollisions(){
  const sr = ship.userData.radius;
  let nearest = null, nearestDist = Infinity;
  for(const p of planets){
    // global planet position (world)
    const worldPos = p.getWorldPosition(new THREE.Vector3());
    const pr = p.userData.radius;
    const d = state.pos.distanceTo(worldPos);
    if(d < pr + sr){
      // push out along normal and damp velocity
      const n = state.pos.clone().sub(worldPos).normalize();
      const penetration = (pr + sr) - d + 1;
      state.pos.add(n.multiplyScalar(penetration));
      // reflect/damp
      const vn = state.vel.dot(n);
      if(vn < 0){
        const refl = state.vel.clone().sub(n.multiplyScalar(vn*1.8));
        state.vel.copy(refl.multiplyScalar(0.28));
      } else state.vel.multiplyScalar(0.2);
    }
    if(d < nearestDist){ nearestDist = d; nearest = p; }
  }
  // HUD nearest
  if(nearest && nearestDist < 200000) nearEl.textContent = nearest.userData.name + ' (' + Math.floor(nearestDist) + ')';
  else nearEl.textContent = '—';
}

// ---------- black hole gravity & ejection ----------
function applyBlackHoles(dt){
  for(const bh of blackHoles){
    const rVec = bh.pos.clone().sub(state.pos);
    const r = Math.max(1, rVec.length());
    // tuned gravitational factor for gameplay (not real G)
    const forceScale = bh.mass * 0.0000000000008; // tuned small
    const accMag = forceScale / (r*r);
    const acc = rVec.normalize().multiplyScalar(accMag);
    // apply acceleration toward BH
    state.vel.add(acc.multiplyScalar(dt*1.0));
    // if inside horizon -> strong ejection but controlled
    if(r < bh.radius * 0.9){
      const ejectDir = state.pos.clone().sub(bh.pos).normalize();
      // apply big outward velocity
      state.vel.copy(ejectDir.multiplyScalar(1500 + Math.random()*2200));
      // move to safe spot outside horizon
      state.pos.copy(bh.pos.clone().add(ejectDir.multiplyScalar(bh.radius*3 + 10000)));
      // visual flash
      flashScreen(300, 0xffddaa);
    }
  }
}

// small screen flash function (HUD overlay)
let tmpFlash = null;
function flashScreen(ms=200, color=0xffffff){
  if(tmpFlash){ camera.remove(tmpFlash); tmpFlash=null; }
  const quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.8}));
  camera.add(quad);
  tmpFlash = quad;
  setTimeout(()=>{ camera.remove(quad); tmpFlash=null; }, ms);
}

// ---------- wormhole interactions: distortion & star stretch ----------
function handleWormholes(dt){
  for(const w of wormholes){
    w.tor.rotation.x += 0.0006; w.tor.rotation.y += 0.0005;
    w.funnel.rotation.y += 0.0008;
    const d = state.pos.distanceTo(w.pos);
    if(d < w.size * 3.0){
      // pull toward center gently
      const pull = w.pos.clone().sub(state.pos).normalize().multiplyScalar((w.size*3.0 - d) * 0.00004);
      state.vel.add(pull.multiplyScalar(dt*60));
      // star stretch: scale up midStars material size and opacity locally
      midStars.material.size = 36 + (w.size*3.0 - Math.min(d, w.size*3.0)) * 0.0006;
      midStars.material.opacity = 0.95;
      if(d < w.size*0.8){
        // near center: teleport to another wormhole (soft)
        const others = wormholes.filter(x=>x!==w);
        if(others.length>0){
          const dest = others[Math.floor(Math.random()*others.length)];
          state.pos.copy(dest.pos.clone().add(new THREE.Vector3((Math.random()-0.5)*dest.size*0.8, (Math.random()-0.5)*dest.size*0.6, (Math.random()-0.5)*dest.size*0.8)));
          state.vel.multiplyScalar(0.12);
          flashScreen(240, 0x66ccff);
        }
      }
    } else {
      // relax midStars
      midStars.material.size = 36;
      midStars.material.opacity = 0.86;
    }
  }
}

// ---------- camera: locked behind ship ----------
const camOffset = new THREE.Vector3(0, 1600, 5200); // fixed transform behind (very distant to encompass huge scale)
function updateCamera(){
  const worldOff = camOffset.clone().applyQuaternion(ship.quaternion);
  camera.position.copy(state.pos.clone().add(worldOff));
  const lookAt = state.pos.clone().add(new THREE.Vector3(0, 600, 0));
  camera.lookAt(lookAt);
  camera.up.set(0,1,0);
}

// ---------- main physics loop (stable, tuned) ----------
let last = performance.now();
const THRUST = 1400;        // tuned for large scale (feel free to reduce)
const DAMP = 0.02;
const MAX_SPEED = 8000;

function loop(){
  const now = performance.now();
  const dt = Math.min(0.06, (now - last)/1000); last = now;

  // controls -> thrust vector
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
  const up = new THREE.Vector3(0,1,0);
  let thrust = new THREE.Vector3();
  thrust.add(forward.multiplyScalar(move.y * THRUST));
  if(move.up) thrust.add(up.clone().multiplyScalar(THRUST*0.6));
  if(move.down) thrust.add(up.clone().multiplyScalar(-THRUST*0.6));
  // integrate: v += (F/m)*dt ; pos += v*dt (scaling adapted to world scale)
  state.vel.add(thrust.clone().multiplyScalar(dt / state.mass));
  // damping
  state.vel.multiplyScalar(1 - Math.min(DAMP, dt*2));
  // clamp speed
  if(state.vel.length() > MAX_SPEED) state.vel.setLength(MAX_SPEED);

  // apply black hole gravity
  applyBlackHoles(dt);

  // position integrate
  state.pos.add(state.vel.clone().multiplyScalar(dt*1.0));

  // planet orbits (very slow)
  for(const p of planets){
    p.userData.angle += p.userData.orbitalSpeed * dt * 60;
    p.position.x = Math.cos(p.userData.angle) * p.userData.distance;
    p.position.z = Math.sin(p.userData.angle) * p.userData.distance;
    p.rotation.y += 0.0001;
    if(p.userData.ring) p.userData.ring.position.copy(p.position);
  }

  // moon orbit (if parented)
  const earth = planets.find(x=>x.userData.name==='Earth');
  if(earth){
    const moon = earth.children.find(c => c.geometry && c.geometry.parameters && c.geometry.parameters.radius);
    if(moon){
      moon.userData.angle = (moon.userData.angle || 0) + 0.002 * dt * 60;
      moon.position.x = Math.cos(moon.userData.angle) * moon.userData.dist;
      moon.position.z = Math.sin(moon.userData.angle) * moon.userData.dist;
    }
  }

  // handle wormhole pull & star stretch
  handleWormholes(dt);

  // apply planet collisions (prevents passing through)
  resolvePlanetCollisions();

  // update ship visuals
  ship.position.copy(state.pos);
  // slight banking visual
  ship.rotation.y -= move.x * 0.01;
  ship.rotation.z = -move.x * 0.08;

  // camera locked behind
  updateCamera();

  // HUD
  speedEl.textContent = Math.floor(state.vel.length());
  // nearest handled inside resolvePlanetCollisions -> nearEl

  // render
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
loop();

// ---------- helper: initial orientation ----------
ship.lookAt(new THREE.Vector3(0,0,-1));

// ---------- resize ----------
window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

// ---------- debug keys ----------
window.addEventListener('keydown', e=>{
  if(e.key.toLowerCase()==='r'){ state.pos.set(7000,1200,0); state.vel.set(0,0,0); }
  if(e.key.toLowerCase()==='1'){ /* teleport to wormhole 1 for testing */ if(wormholes[0]) state.pos.copy(wormholes[0].pos.clone().add(new THREE.Vector3(0, wormholes[0].size*1.1, 0))); state.vel.set(0,0,0); }
  if(e.key.toLowerCase()==='b'){ if(blackHoles[0]) state.pos.copy(blackHoles[0].pos.clone().add(new THREE.Vector3(blackHoles[0].radius*3, 0, blackHoles[0].radius*3))); state.vel.set(0,0,0); }
});

// ---------- end ----------
</script>
</body>
</html>
