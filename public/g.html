<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>SpaceGame — Système Solaire Réaliste</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<style>
html,body{font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif; margin:0;height:100%;background:#000;-webkit-user-select: none; user-select:none}
canvas{display:block}
#loader{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#fff;font-family:system-ui,Arial;z-index:10}
.joystick{position:fixed;left:16px;bottom:16px;width:100px;height:100px;border-radius:50%;background:rgba(255,255,255,0.06);touch-action:none}
.joystick-inner{width:50px;height:50px;border-radius:50%;background:rgba(255,255,255,0.18);position:relative;left:25px;top:25px;pointer-events:none}
.btn{position:fixed;right:16px;width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.08);text-align:center;line-height:60px;color:#fff}
.btn.up{bottom:96px}.btn.down{bottom:16px}
#galaxyLabel{position:fixed;left:50%;transform:translateX(-50%);top:16px;color:#fff;padding:8px 12px;background:rgba(0,0,0,0.35);border-radius:8px;font-family:system-ui,Arial;z-index:9}
</style>
</head>
<body>
<div id="loader">Chargement...</div>
<div id="galaxyLabel">Système solaire</div>
<div class="joystick" id="joystick"><div class="joystick-inner" id="joyInner"></div></div>
<div class="btn up" id="btnUp">↑</div>
<div class="btn down" id="btnDown">↓</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

const loaderEl = document.getElementById('loader');
const galaxyLabel = document.getElementById('galaxyLabel');

// helper safe loader
const texLoader = new THREE.TextureLoader();
async function loadSafe(url){
  return new Promise(resolve=>{
    texLoader.load(url, tex=>resolve(tex), undefined, ()=>resolve(null));
  });
}

// Textures — sources publiques (fallback si non trouvées)
const texMap = {
  mercury: 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/mercury.jpg',
  venus:   'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/venus.jpg',
  earth:   'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
  earthClouds: 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
  moon:    'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg',
  mars:    'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/mars_1k_color.jpg',
  jupiter: 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/jupiter.jpg',
  saturn:  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/saturn.jpg',
  saturnRing: 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/saturnringcolor.jpg',
  uranus:  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/uranus.jpg',
  neptune:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/neptune.jpg'
};

const [
  mercuryTex, venusTex, earthTex, earthCloudsTex, moonTex,
  marsTex, jupiterTex, saturnTex, saturnRingTex, uranusTex, neptuneTex
] = await Promise.all([
  loadSafe(texMap.mercury), loadSafe(texMap.venus), loadSafe(texMap.earth),
  loadSafe(texMap.earthClouds), loadSafe(texMap.moon), loadSafe(texMap.mars),
  loadSafe(texMap.jupiter), loadSafe(texMap.saturn), loadSafe(texMap.saturnRing),
  loadSafe(texMap.uranus), loadSafe(texMap.neptune)
]);

loaderEl.style.display='none';

// SCENE / CAMERA / RENDERER
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000010);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 20000);
camera.position.set(0,20,80);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// LIGHTS
const ambient = new THREE.AmbientLight(0x666666); scene.add(ambient);
let sunLight = new THREE.PointLight(0xffffff,1.6,0); sunLight.position.set(0,0,0); scene.add(sunLight);

// Central star (sun)
const sunMat = new THREE.MeshBasicMaterial({color:0xffee88});
const sunMesh = new THREE.Mesh(new THREE.SphereGeometry(14, 32, 32), sunMat);
scene.add(sunMesh);

// Create round star sprite texture (canvas) for soft round stars and point sprites
function createRoundSprite(){
  const size = 64;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  const grd = ctx.createRadialGradient(size/2,size/2,2,size/2,size/2,size/2);
  grd.addColorStop(0,'rgba(255,255,255,1)');
  grd.addColorStop(0.2,'rgba(160,200,255,0.9)');
  grd.addColorStop(0.4,'rgba(120,160,255,0.6)');
  grd.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  return tex;
}
const starSprite = createRoundSprite();

// STARFIELDS (round luminous stars)
(function makeStars(){
  const layers = [
    {count: 800, radiusMin: 800, radiusMax: 3000, size: 4, color: 0xffffff, opacity:0.9, twinkle:0.0002},
    {count: 400, radiusMin: 300, radiusMax: 1400, size: 8, color: 0xfff0aa, opacity:0.85, twinkle:0.0004}
  ];
  window._starFields = [];
  for(const L of layers){
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(L.count*3);
    const sizes = new Float32Array(L.count);
    for(let i=0;i<L.count;i++){
      const r = L.radiusMin + Math.random()*(L.radiusMax-L.radiusMin);
      const theta = Math.random()*Math.PI*2;
      const phi = (Math.random()-0.5)*Math.PI;
      positions[i*3] = Math.cos(theta)*Math.cos(phi)*r;
      positions[i*3+1] = Math.sin(phi)*r;
      positions[i*3+2] = Math.sin(theta)*Math.cos(phi)*r;
      sizes[i] = L.size * (0.7 + Math.random()*0.6);
    }
    geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geom.setAttribute('size', new THREE.BufferAttribute(sizes,1));
    const mat = new THREE.PointsMaterial({
      map: starSprite,
      size: L.size,
      transparent: true,
      opacity: L.opacity,
      depthWrite:false,
      blending: THREE.AdditiveBlending
    });
    const points = new THREE.Points(geom, mat);
    scene.add(points);
    window._starFields.push({points,mat,twinkle:L.twinkle});
  }
})();

// SPACIAL DUST PARTICLES (small, subtle)
(function makeDust(){
  const count = 1500;
  const geom = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r = 50 + Math.random()*2500;
    const theta = Math.random()*Math.PI*2;
    const phi = (Math.random()-0.5)*Math.PI;
    pos[i*3] = Math.cos(theta)*Math.cos(phi)*r;
    pos[i*3+1] = Math.sin(phi)*r*0.2; // flatter distribution
    pos[i*3+2] = Math.sin(theta)*Math.cos(phi)*r;
  }
  geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({size:1.2, transparent:true, opacity:0.12, depthWrite:false, blending:THREE.AdditiveBlending, color:0xfff7ef});
  const pts = new THREE.Points(geom, mat);
  scene.add(pts);
  window._dust = {pts,mat};
})();

// Planet factory: creates realistic textured planets with orbit params
function makePlanet(name, radius, distance, texture, opts = {}){
  const geom = new THREE.SphereGeometry(radius, opts.segments||32, opts.segments||32);
  const matOptions = {metalness:0.02, roughness:0.7};
  if(texture) matOptions.map = texture;
  else matOptions.color = opts.color || 0x999999;
  const mat = new THREE.MeshStandardMaterial(matOptions);
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.set(distance, 0, 0);
  // custom userData for orbital motion
  mesh.userData = {
    name,
    distance,
    orbitalSpeed: (opts.orbitalPeriod? (1/opts.orbitalPeriod) : (0.00005 + Math.random()*0.0001)) * 0.4, // slowed by factor
    rotationSpeed: opts.rotationSpeed || 0.0005
  };
  // rings (optional)
  if(opts.ring){
    const ringGeo = new THREE.RingGeometry(opts.ring.inner || radius*1.2, opts.ring.outer || radius*2.0, 128);
    const ringMat = new THREE.MeshBasicMaterial({map: opts.ring.map || null, side: THREE.DoubleSide, transparent:true, opacity:0.9});
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI/2.2;
    ring.position.copy(mesh.position);
    scene.add(ring);
    mesh.userData.ring = ring;
  }
  scene.add(mesh);
  return mesh;
}

// Real solar system (scaled for gameplay, not real units). Distances and radii are scaled down.
const planets = [];
// Mercury
planets.push(makePlanet('Mercury', 1.2, 78, mercuryTex, {orbitalPeriod:88, rotationSpeed:0.0008}));
// Venus
planets.push(makePlanet('Venus', 1.8, 80, venusTex, {orbitalPeriod:225, rotationSpeed:0.0002}));
// Earth with clouds and moon
const earth = makePlanet('Earth', 2.0, 120, earthTex, {orbitalPeriod:365, rotationSpeed:0.001});
planets.push(earth);
if(earthCloudsTex){
  const clouds = new THREE.Mesh(new THREE.SphereGeometry(2.06,32,32),
    new THREE.MeshPhongMaterial({map:earthCloudsTex, transparent:true, opacity:0.9, depthWrite:false}));
  earth.add(clouds);
}
// Moon as satellite of Earth
const moon = new THREE.Mesh(new THREE.SphereGeometry(0.54,24,24), new THREE.MeshStandardMaterial({map:moonTex}));
moon.position.set(4.5,0,0); earth.add(moon);
moon.userData = {orbitSpeed: 0.01, distance:4.5, angle: 0};

// Mars
planets.push(makePlanet('Mars', 1.1, 75, marsTex, {orbitalPeriod:687, rotationSpeed:0.001}));
// Jupiter
planets.push(makePlanet('Jupiter', 5.5, 120, jupiterTex, {orbitalPeriod:4333, rotationSpeed:0.002}));
// Saturn (with ring)
planets.push(makePlanet('Saturn', 4.8, 170, saturnTex, {orbitalPeriod:10759, rotationSpeed:0.0015, ring:{inner:6, outer:9, map: saturnRingTex}}));
// Uranus
planets.push(makePlanet('Uranus', 3.0, 210, uranusTex, {orbitalPeriod:30687, rotationSpeed:0.0008}));
// Neptune
planets.push(makePlanet('Neptune', 2.9, 260, neptuneTex, {orbitalPeriod:60190, rotationSpeed:0.0009}));

// optional: dwarf Pluto (small)
const pluto = makePlanet('Pluto', 0.6, 300, null, {orbitalPeriod:90560, rotationSpeed:0.0004});
pluto.material && (pluto.material.color = new THREE.Color(0x9b7b6a));
planets.push(pluto);

// slow down global orbital speeds factor (gameplay)
const ORBIT_SPEED_FACTOR = 0.7; // lower => slower

// Ship (grey)
function assembleShip(){
  const group=new THREE.Group();
  const bodyMat=new THREE.MeshStandardMaterial({color:0x8a8f92,metalness:0.85,roughness:0.2});
  const body=new THREE.Mesh(new THREE.ConeGeometry(0.6,2.2,24),bodyMat);
  body.rotation.x=Math.PI/2;
  group.add(body);
  const glass=new THREE.Mesh(new THREE.SphereGeometry(0.42,18,18),new THREE.MeshPhysicalMaterial({color:0x222831,transmission:0.6,transparent:true,opacity:0.95,roughness:0.1}));
  glass.position.set(0,0.45,0.6);
  group.add(glass);
  const wingMat=bodyMat.clone();
  const wingL=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.5,1.2),wingMat);
  wingL.position.set(-0.9,0,-0.2); wingL.rotation.z=0.06;
  const wingR=wingL.clone(); wingR.position.set(0.9,0,-0.2);
  group.add(wingL,wingR);
  const fin=new THREE.Mesh(new THREE.BoxGeometry(0.06,0.6,0.8),wingMat);
  fin.position.set(0,-0.6,-0.2); fin.rotation.x=0.18; group.add(fin);
  const engineMat=new THREE.MeshStandardMaterial({color:0x2b2b2b,metalness:0.9,roughness:0.18});
  const thrL=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,12),engineMat); thrL.rotation.x=Math.PI/2; thrL.position.set(-0.35,-1.05,0);
  const thrR=thrL.clone(); thrR.position.set(0.35,-1.05,0); group.add(thrL,thrR);
  const ringMat=new THREE.MeshBasicMaterial({color:0xffaa00,transparent:true,opacity:0.9});
  const ringL=new THREE.Mesh(new THREE.TorusGeometry(0.16,0.03,8,32),ringMat); ringL.rotation.x=Math.PI/2; ringL.position.copy(thrL.position);
  const ringR=ringL.clone(); ringR.position.copy(thrR.position); group.add(ringL,ringR);
  const exhaustCount=80; const arr=new Float32Array(exhaustCount*3);
  for(let i=0;i<exhaustCount;i++){arr[i*3]=(Math.random()-0.5)*0.25;arr[i*3+1]=-1.4-Math.random()*0.8;arr[i*3+2]=(Math.random()-0.5)*0.25;}
  const exhaustGeom=new THREE.BufferGeometry(); exhaustGeom.setAttribute('position',new THREE.BufferAttribute(arr,3));
  const exhaustMat=new THREE.PointsMaterial({color:0xffaa66,size:0.12,transparent:true,opacity:0.9,depthWrite:false});
  const exhaust=new THREE.Points(exhaustGeom,exhaustMat); group.add(exhaust);
  const l1=new THREE.PointLight(0xffaa66,0.6,6); l1.position.set(-0.35,-1.05,0); const l2=l1.clone(); l2.position.set(0.35,-1.05,0); group.add(l1,l2);
  group.userData={setThrusterPower(p){const power=Math.max(0,Math.min(1,p));exhaustMat.size=0.05+power*0.24;exhaustMat.opacity=0.12+power*0.88;l1.intensity=0.2+power*1.2;l2.intensity=0.2+power*1.2}, updateExhaust(){const a=exhaustGeom.attributes.position.array;for(let i=0;i<a.length/3;i++){const idx=i*3;a[idx]+= (Math.random()-0.5)*0.004;a[idx+1]-=0.002-Math.random()*0.006;a[idx+2]+=(Math.random()-0.5)*0.004;if(a[idx+1]<-3.2) a[idx+1]=-1.4-Math.random()*0.8;}exhaustGeom.attributes.position.needsUpdate=true}};
  return group;
}

let ship = assembleShip();
// start position moved OUT of the sun — user requested starting outside sun
ship.position.set(28, 6, 12); // near Mercury orbit but not in star
scene.add(ship);

// Controls (touch)
let move={x:0,y:0,up:false,down:false};
const joy=document.getElementById('joystick'), joyInner=document.getElementById('joyInner');
joy.addEventListener('touchstart',e=>e.preventDefault());
joy.addEventListener('touchmove',e=>{
  const t=e.touches[0]; const r=joy.getBoundingClientRect();
  move.x=Math.max(-1,Math.min(1,(t.clientX-(r.left+r.width/2))/(r.width/2)));
  move.y=Math.max(-1,Math.min(1,-(t.clientY-(r.top+r.height/2))/(r.height/2)));
  joyInner.style.transform=`translate(${move.x*25}px, ${-move.y*25}px)`;
});
joy.addEventListener('touchend',()=>{move.x=0;move.y=0;joyInner.style.transform='translate(0,0)';});
document.getElementById('btnUp').addEventListener('touchstart',()=>move.up=true);
document.getElementById('btnUp').addEventListener('touchend',()=>move.up=false);
document.getElementById('btnDown').addEventListener('touchstart',()=>move.down=true);
document.getElementById('btnDown').addEventListener('touchend',()=>move.down=false);

// Physics
let velocity=new THREE.Vector3(), direction=new THREE.Vector3();
const forwardVec = new THREE.Vector3(0,0,-1);

// Orbit helpers for moons and planets (store angles)
planets.forEach(p => { p.userData.angle = Math.random()*Math.PI*2; });
moon.userData.angle = 0;

// animation loop
function animate(){
  requestAnimationFrame(animate);
  const now = Date.now();

  // update orbits (slower, realistic feel)
  planets.forEach(p=>{
    // use stored userData
    p.userData.angle += p.userData.orbitalSpeed * ORBIT_SPEED_FACTOR;
    const a = p.userData.angle;
    const d = p.userData.distance;
    p.position.x = Math.cos(a) * d;
    p.position.z = Math.sin(a) * d;
    if(p.userData.ring) p.userData.ring.position.copy(p.position);
    p.rotation.y += (p.userData.rotationSpeed || 0.0005);
  });

  // moon orbit around earth
  moon.userData.angle += 0.002;
  moon.position.x = Math.cos(moon.userData.angle) * moon.userData.distance;
  moon.position.z = Math.sin(moon.userData.angle) * moon.userData.distance;

  // slow twinkle for starfields
  if(window._starFields){
    window._starFields.forEach((sf, i) => {
      sf.mat.opacity = 0.75 + 0.15*Math.sin(now*sf.twinkle* (i+1) );
    });
  }

  // dust subtle drift (rotate entire dust particle system a bit)
  if(window._dust && window._dust.pts){
    window._dust.pts.rotation.y += 0.00001;
  }

  // ship controls
  direction.set(0,0,0);
  const localF = forwardVec.clone().applyEuler(ship.rotation);
  direction.add(localF.multiplyScalar(move.y*0.45));
  if(move.up) direction.y += 0.12;
  if(move.down) direction.y -= 0.12;
  velocity.lerp(direction, 0.06);
  ship.position.add(velocity);
  ship.rotation.y -= move.x*0.04;
};
  // camera follow
  const desired = ship.position.clone().add(new THREE.Vector3(0,4,14).applyEuler(ship.rotation));
  camera.position.lerp(desired, 0.08);
  camera.lookAt(ship.position);

  renderer.render(scene, camera);
}
animate();

// resize handling
window.addEventListener('resize', ()=>{camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);});

// desktop debug: G = reposition near sun, H = reset to starting safe position
window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase()==='g'){ ship.position.set(0,0,0); velocity.set(0,0,0); }
  if(e.key.toLowerCase()==='h'){ ship.position.set(28,6,12); velocity.set(0,0,0); }
});

</script>
</body>
</html>
