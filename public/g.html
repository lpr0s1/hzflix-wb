<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Space — Flat Ship + Wormholes & Black Holes</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<style>
  html,body{margin:0;height:100%;background:#000;user-select:none;overflow:hidden}
  canvas{display:block}
  #hud{position:fixed;left:12px;top:12px;color:#fff;font-family:system-ui,Arial;z-index:99;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px}
  .joystick{position:fixed;left:12px;bottom:12px;width:100px;height:100px;border-radius:50%;background:rgba(255,255,255,0.06);touch-action:none;z-index:99}
  .joystick-inner{width:50px;height:50px;border-radius:50%;background:rgba(255,255,255,0.18);position:relative;left:25px;top:25px;pointer-events:none}
  .btn{position:fixed;right:12px;width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.08);text-align:center;line-height:60px;color:#fff;z-index:99}
  .btn.up{bottom:92px}.btn.down{bottom:12px}
</style>
</head>
<body>
<div id="hud">Vitesse: <span id="speed">0</span> | Proche: <span id="near">—</span></div>
<div class="joystick" id="joystick"><div class="joystick-inner" id="joyInner"></div></div>
<div class="btn up" id="btnUp">↑</div>
<div class="btn down" id="btnDown">↓</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

// ---------- utils ----------
const speedEl = document.getElementById('speed');
const nearEl = document.getElementById('near');
const texLoader = new THREE.TextureLoader();
const loadSafe = url => new Promise(resolve => texLoader.load(url, t=>resolve(t), undefined, ()=>resolve(null)));

// ---------- scene, camera, renderer ----------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000007);
const camera = new THREE.PerspectiveCamera(58, innerWidth/innerHeight, 0.1, 5e6);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// ---------- lights ----------
scene.add(new THREE.AmbientLight(0x666666));
const sunLight = new THREE.PointLight(0xffffff, 3.4, 0); sunLight.position.set(0,0,0); scene.add(sunLight);

// ---------- sun ----------
const sun = new THREE.Mesh(new THREE.SphereGeometry(12000, 32, 32), new THREE.MeshBasicMaterial({color:0xffee88}));
scene.add(sun);

// ---------- star sprite (round) ----------
function makeStarSprite(size=128){
  const c = document.createElement('canvas'); c.width=c.height=size;
  const ctx = c.getContext('2d');
  const g = ctx.createRadialGradient(size/2,size/2,1,size/2,size/2,size/2);
  g.addColorStop(0,'rgba(255,255,255,1)');
  g.addColorStop(0.25,'rgba(170,200,255,0.95)');
  g.addColorStop(0.6,'rgba(120,160,255,0.35)');
  g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(c); tex.minFilter = THREE.LinearFilter; return tex;
}
const starSprite = makeStarSprite();

// ---------- starfields ----------
function addStars(count, rMin, rMax, size){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r = rMin + Math.random()*(rMax-rMin);
    const th = Math.random()*Math.PI*2; const ph = (Math.random()-0.5)*Math.PI;
    pos[3*i] = Math.cos(th)*Math.cos(ph)*r;
    pos[3*i+1] = Math.sin(ph)*r;
    pos[3*i+2] = Math.sin(th)*Math.cos(ph)*r;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({map:starSprite, size:size, transparent:true, opacity:0.95, depthWrite:false, blending:THREE.AdditiveBlending});
  const pts = new THREE.Points(geo, mat); scene.add(pts); return pts;
}
const farStars = addStars(3500, 200000, 900000, 200);
const midStars = addStars(1800, 60000, 200000, 60);

// ---------- dust (space particles) ----------
(function(){
  const N = 8000;
  const geo = new THREE.BufferGeometry();
  const arr = new Float32Array(N*3);
  for(let i=0;i<N;i++){
    const r = 30000 + Math.random()*900000;
    const th = Math.random()*Math.PI*2; const ph = (Math.random()-0.5)*0.15;
    arr[3*i] = Math.cos(th)*Math.cos(ph)*r;
    arr[3*i+1] = Math.sin(ph)*r;
    arr[3*i+2] = Math.sin(th)*Math.cos(ph)*r;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const mat = new THREE.PointsMaterial({size:30, color:0xfff7ef, transparent:true, opacity:0.045, depthWrite:false, blending:THREE.AdditiveBlending});
  const pts = new THREE.Points(geo, mat); scene.add(pts);
})();

// ---------- solar system data (very large scale & big radii) ----------
const planetSpecs = [
  // name, radius, distanceFromSun, texture, ringTexture?
  ['Mercury',  3000,  60000,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/mercury.jpg', null],
  ['Venus',    6500, 110000,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/venus.jpg', null],
  ['Earth',    7200, 165000,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg', null],
  ['Moon',     1800,  9000,   'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg', null], // will parent to Earth
  ['Mars',     3600, 230000,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/mars_1k_color.jpg', null],
  ['Jupiter', 16000, 410000,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/jupiter.jpg', null],
  ['Saturn',  15200, 760000,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/saturn.jpg', 'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/saturnringcolor.jpg'],
  ['Uranus',  9800, 1200000,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/uranus.jpg', null],
  ['Neptune', 9400, 1700000,  'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/neptune.jpg', null],
  ['Pluto',   1600, 2300000,  null, null]
];

const planets = [];
async function buildPlanets(){
  for(const spec of planetSpecs){
    const [name, rad, dist, texUrl, ringUrl] = spec;
    const tex = texUrl ? await loadSafe(texUrl) : null;
    const geo = new THREE.SphereGeometry(rad, 48, 48);
    const mat = new THREE.MeshStandardMaterial(tex ? {map:tex, metalness:0.02, roughness:0.75} : {color:0x888888, metalness:0.03, roughness:0.8});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(dist, 0, 0);
    mesh.userData = { name, radius: rad, distance: dist, angle: Math.random()*Math.PI*2, speed: (0.000005 + Math.random()*0.00001) };
    scene.add(mesh);
    if(ringUrl){
      const rtex = await loadSafe(ringUrl);
      const ring = new THREE.Mesh(new THREE.RingGeometry(rad*1.2, rad*2.2, 128),
        new THREE.MeshBasicMaterial({map:rtex, side:THREE.DoubleSide, transparent:true, opacity:0.9}));
      ring.rotation.x = Math.PI/2.2; ring.position.copy(mesh.position); scene.add(ring); mesh.userData.ring = ring;
    }
    planets.push(mesh);
  }
  // parent moon to Earth
  const earth = planets.find(p=>p.userData.name==='Earth');
  const moon = planets.find(p=>p.userData.name==='Moon');
  if(earth && moon){
    moon.position.set(earth.userData.radius + 35000, 0, 0);
    moon.userData = { orbitSpeed: 0.0012, distance: earth.userData.radius + 35000, angle: 0 };
    earth.add(moon);
  }
}
await buildPlanets();

// ---------- ship: flat with rear turbos (small relative to planets) ----------
function buildShip(){
  const g = new THREE.Group();
  // hull (flat plate)
  const hull = new THREE.Mesh(new THREE.BoxGeometry(1200, 80, 2200), new THREE.MeshStandardMaterial({color:0x8b8f91, metalness:0.9, roughness:0.2}));
  hull.scale.set(1,0.18,1); hull.position.set(0,12,180);
  g.add(hull);
  // cockpit
  const cockpit = new THREE.Mesh(new THREE.SphereGeometry(220, 18, 18), new THREE.MeshPhysicalMaterial({color:0x0b2a3d, transmission:0.6, transparent:true, opacity:0.92}));
  cockpit.position.set(0,96,560); g.add(cockpit);
  // rear turbos
  const turboMat = new THREE.MeshStandardMaterial({color:0x1b1b1b, metalness:0.95, roughness:0.12});
  const turboL = new THREE.Mesh(new THREE.CylinderGeometry(120,140,480,20), turboMat); turboL.rotation.x = Math.PI/2; turboL.position.set(-320, -40, -820);
  const turboR = turboL.clone(); turboR.position.set(320, -40, -820); g.add(turboL, turboR);
  // exhaust points
  const pN = 200; const arr = new Float32Array(pN*3);
  for(let i=0;i<pN;i++){ arr[3*i] = (Math.random()-0.5)*220; arr[3*i+1] = -60 - Math.random()*240; arr[3*i+2] = -950 - Math.random()*340; }
  const pGeo = new THREE.BufferGeometry(); pGeo.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const pMat = new THREE.PointsMaterial({color:0xffa75f, size:40, transparent:true, opacity:0.95, depthWrite:false});
  const exhaust = new THREE.Points(pGeo, pMat); g.add(exhaust);
  g.userData.radius = 800; // collision radius relative to planet sizes
  return g;
}
const ship = buildShip();
ship.position.set(28000, 9000, 0); // start well away from sun and planets
scene.add(ship);

// ---------- physics state ----------
const state = { pos: ship.position.clone(), vel: new THREE.Vector3(0,0,0), mass: 1.0 };

// ---------- controls ----------
let move = {x:0,y:0,up:false,down:false};
const joy = document.getElementById('joystick'), joyInner = document.getElementById('joyInner');
joy.addEventListener('touchstart', e=>e.preventDefault());
joy.addEventListener('touchmove', e=>{
  const t=e.touches[0], r=joy.getBoundingClientRect();
  move.x = Math.max(-1, Math.min(1, (t.clientX - (r.left + r.width/2))/(r.width/2)));
  move.y = Math.max(-1, Math.min(1, -(t.clientY - (r.top + r.height/2))/(r.height/2)));
  joyInner.style.transform = `translate(${move.x*25}px, ${-move.y*25}px)`;
});
joy.addEventListener('touchend', ()=>{ move.x=0; move.y=0; joyInner.style.transform='translate(0,0)'; });
document.getElementById('btnUp').addEventListener('touchstart', ()=>move.up=true);
document.getElementById('btnUp').addEventListener('touchend', ()=>move.up=false);
document.getElementById('btnDown').addEventListener('touchstart', ()=>move.down=true);
document.getElementById('btnDown').addEventListener('touchend', ()=>move.down=false);
window.addEventListener('keydown', e=>{
  if(e.key==='w') move.y=1; if(e.key==='s') move.y=-1; if(e.key==='a') move.x=-1; if(e.key==='d') move.x=1;
  if(e.key==='ArrowUp') move.up=true; if(e.key==='ArrowDown') move.down=true;
});
window.addEventListener('keyup', e=>{
  if(['w','s'].includes(e.key)) move.y=0; if(['a','d'].includes(e.key)) move.x=0;
  if(e.key==='ArrowUp') move.up=false; if(e.key==='ArrowDown') move.down=false;
});

// ---------- wormholes (7) with visual distortion + star stretch ----------
const wormholes = [];
function makeWormhole(pos, size=14000){
  const tor = new THREE.Mesh(new THREE.TorusGeometry(size, size*0.18, 24, 180),
    new THREE.MeshBasicMaterial({color:0x66ccff, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, side:THREE.DoubleSide}));
  tor.position.copy(pos); scene.add(tor);
  // funnel particles
  const N = 4000; const arr = new Float32Array(N*3);
  for(let i=0;i<N;i++){
    const r = Math.random()*size*0.9; const a = Math.random()*Math.PI*2; const z = (Math.random()-0.5)*size*2.2;
    arr[3*i] = Math.cos(a)*r; arr[3*i+1] = Math.sin(a)*r; arr[3*i+2] = z;
  }
  const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const p = new THREE.Points(g, new THREE.PointsMaterial({size:60, color:0xaaffff, transparent:true, opacity:0.95, depthWrite:false, blending:THREE.AdditiveBlending}));
  p.position.copy(pos); scene.add(p);
  wormholes.push({tor, funnel:p, pos:pos.clone(), size});
}
for(let i=0;i<7;i++){
  const a = Math.random()*Math.PI*2;
  const d = 1.2e6 + Math.random()*1.4e6; // far
  const p = new THREE.Vector3(Math.cos(a)*d, (Math.random()-0.5)*2e5, Math.sin(a)*d);
  makeWormhole(p, 8e4 + Math.random()*8e4);
}

// ---------- black holes (2) with gravity ~1/r^2 ----------
const blackHoles = [];
function makeBlackHole(pos, mass, radius){
  const bh = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), new THREE.MeshBasicMaterial({color:0x000000}));
  bh.position.copy(pos); scene.add(bh);
  const disc = new THREE.Mesh(new THREE.RingGeometry(radius*1.8, radius*5.0, 64), new THREE.MeshBasicMaterial({color:0x442266, side:THREE.DoubleSide, transparent:true, opacity:0.5}));
  disc.rotation.x = Math.PI/2; disc.position.copy(pos); scene.add(disc);
  blackHoles.push({pos:pos.clone(), mass, radius, mesh:bh});
}
makeBlackHole(new THREE.Vector3(-2.4e6, 0, -1.1e6), 3e14, 1.2e5);
makeBlackHole(new THREE.Vector3(2.8e6, -6e5, 1.9e6), 2.1e14, 9e4);

// ---------- collision detection (spherical) ----------
function resolvePlanetCollisions(){
  const sr = ship.userData.radius;
  let nearest = null, nearestDist = Infinity;
  for(const p of planets){
    const worldPos = p.getWorldPosition(new THREE.Vector3());
    const pr = p.userData.radius;
    const d = state.pos.distanceTo(worldPos);
    if(d < pr + sr){
      // push outside & damp/reflect
      const n = state.pos.clone().sub(worldPos).normalize();
      const pen = (pr + sr) - d + 1;
      state.pos.add(n.multiplyScalar(pen));
      const vn = state.vel.dot(n);
      if(vn < 0){
        const refl = state.vel.clone().sub(n.multiplyScalar(vn*1.6));
        state.vel.copy(refl.multiplyScalar(0.28));
      } else state.vel.multiplyScalar(0.2);
    }
    if(d < nearestDist){ nearestDist = d; nearest = p; }
  }
  if(nearest && nearestDist < 1.5e6) nearEl.textContent = nearest.userData.name + ' (' + Math.floor(nearestDist).toLocaleString() + ' m)';
  else nearEl.textContent = '—';
}

// ---------- black holes gravity & ejection ----------
function applyBlackHoles(dt){
  for(const bh of blackHoles){
    const rVec = bh.pos.clone().sub(state.pos);
    const r = Math.max(1, rVec.length());
    const strength = bh.mass * 1e-24; // tuned game constant
    const accMag = strength / (r*r);
    const acc = rVec.normalize().multiplyScalar(accMag);
    state.vel.add(acc.multiplyScalar(dt));
    // event horizon: if too close, eject outward violently and move to safe distance
    if(r < bh.radius * 0.88){
      const ejectDir = state.pos.clone().sub(bh.pos).normalize();
      state.vel.copy(ejectDir.multiplyScalar(5e3 + Math.random()*6e3));
      state.pos.copy(bh.pos.clone().add(ejectDir.multiplyScalar(bh.radius*3 + 6e4)));
      flashScreen(350, 0xffddaa);
    }
  }
}

// small flash overlay
let overlay=null;
function flashScreen(ms=200, color=0xffffff){
  if(overlay){ camera.remove(overlay); overlay=null; }
  const quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.8}));
  camera.add(quad); overlay = quad;
  setTimeout(()=>{ if(overlay){ camera.remove(overlay); overlay=null; } }, ms);
}

// ---------- wormhole interactions: distortion & star stretch ----------
function handleWormholes(dt){
  for(const w of wormholes){
    w.tor.rotation.x += 0.0012;
    w.tor.rotation.y += 0.0010;
    w.funnel.rotation.y += 0.0009;
    const d = state.pos.distanceTo(w.pos);
    if(d < w.size * 2.4){
      // gentle inward pull
      const pull = w.pos.clone().sub(state.pos).normalize().multiplyScalar((w.size*2.4 - d) * 0.00006);
      state.vel.add(pull.multiplyScalar(dt*60));
      // star stretch: temporarily increase midStars size and opacity
      midStars.material.size = 60 + (w.size*2.4 - Math.min(d, w.size*2.4)) * 0.0008;
      midStars.material.opacity = 1.0;
      // camera FOV wobble to simulate distortion
      camera.fov = 58 + Math.sin(performance.now()*0.003 + d*0.00001) * Math.min(12, (w.size*1.8 - d) * 0.00012);
      camera.updateProjectionMatrix();
      if(d < w.size*0.45){
        // teleport to a random other wormhole softly
        const others = wormholes.filter(x=>x!==w);
        if(others.length>0){
          const dest = others[Math.floor(Math.random()*others.length)];
          state.pos.copy(dest.pos.clone().add(new THREE.Vector3((Math.random()-0.5)*dest.size*0.6, (Math.random()-0.5)*dest.size*0.4, (Math.random()-0.5)*dest.size*0.6)));
          state.vel.multiplyScalar(0.12);
          flashScreen(220, 0x66ccff);
        }
      }
    } else {
      // relax starfield and FOV
      midStars.material.size = 60;
      midStars.material.opacity = 0.9;
      camera.fov = 58;
      camera.updateProjectionMatrix();
    }
  }
}

// ---------- camera locked behind ship ----------
const camOffset = new THREE.Vector3(0, 9000, 26000); // fixed behind for huge scale
function updateCamera(){
  const worldOff = camOffset.clone().applyQuaternion(ship.quaternion);
  camera.position.copy(state.pos.clone().add(worldOff));
  camera.lookAt(state.pos.clone().add(new THREE.Vector3(0, 2400, 0)));
  camera.up.set(0,1,0);
}

// ---------- main physics constants (tuned) ----------
const THRUST = 1.5e5;   // tuned to world scale
const DAMPING = 0.006;
const MAX_SPEED = 6e4;

// ---------- main loop ----------
let last = performance.now();
function tick(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - last)/1000); last = now;

  // controls -> thrust vector
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
  const up = new THREE.Vector3(0,1,0);
  let thrust = new THREE.Vector3();
  thrust.add(forward.clone().multiplyScalar(move.y * THRUST));
  if(move.up) thrust.add(up.clone().multiplyScalar(THRUST*0.6));
  if(move.down) thrust.add(up.clone().multiplyScalar(-THRUST*0.6));
  state.vel.add(thrust.multiplyScalar(dt / state.mass));
  // damping
  state.vel.multiplyScalar(1 - Math.min(DAMPING, dt*2));
  // clamp speed
  if(state.vel.length() > MAX_SPEED) state.vel.setLength(MAX_SPEED);

  // black hole gravity
  applyBlackHoles(dt);

  // integrate position
  state.pos.add(state.vel.clone().multiplyScalar(dt));

  // planet orbits (very slow)
  for(const p of planets){
    p.userData.angle += p.userData.speed * dt * 60;
    p.position.x = Math.cos(p.userData.angle) * p.userData.distance;
    p.position.z = Math.sin(p.userData.angle) * p.userData.distance;
    if(p.userData.ring) p.userData.ring.position.copy(p.position);
  }
  // moon local orbit (if present)
  const earth = planets.find(p=>p.userData.name==='Earth');
  if(earth){
    const moon = earth.children.find(c=>c.userData && c.userData.orbitSpeed);
    if(moon){ moon.userData.angle = (moon.userData.angle || 0) + moon.userData.orbitSpeed * dt * 60; moon.position.x = Math.cos(moon.userData.angle) * moon.userData.distance; moon.position.z = Math.sin(moon.userData.angle) * moon.userData.distance; }
  }

  // wormhole interactions
  handleWormholes(dt);

  // collisions with planets
  resolvePlanetCollisions();

  // apply ship transform & banking visual
  ship.position.copy(state.pos);
  ship.rotation.y -= move.x * 0.006; // slow yaw for big ship
  ship.rotation.z = -move.x * 0.04;

  // camera behind ship
  updateCamera();

  // HUD
  speedEl.textContent = Math.floor(state.vel.length()).toLocaleString();

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();

// ---------- add ship model to scene & initial orientation ----------
ship.lookAt(new THREE.Vector3(0,0,-1));

// ---------- resize ----------
window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

// ---------- debug keys ----------
window.addEventListener('keydown', e=>{
  if(e.key.toLowerCase()==='r'){ state.pos.set(28000,9000,0); state.vel.set(0,0,0); }
  if(e.key.toLowerCase()==='g'){ if(wormholes[0]) state.pos.copy(wormholes[0].pos.clone().add(new THREE.Vector3(0, wormholes[0].size*0.3, 0))); state.vel.set(0,0,0); }
  if(e.key.toLowerCase()==='b'){ if(blackHoles[0]) state.pos.copy(blackHoles[0].pos.clone().add(new THREE.Vector3(blackHoles[0].radius*3,0,blackHoles[0].radius*3))); state.vel.set(0,0,0); }
});

// ---------- end ----------
</script>
</body>
</html>
