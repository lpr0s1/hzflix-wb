<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>SpaceGame Mobile 3D vaisseau assemblé</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<style>
html, body { margin:0; padding:0; width:100%; height:100%; background:black; -webkit-user-select:none; user-select:none; }
canvas { display:block; }
#loader { position:absolute; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; background:black; color:#fff; font-family:sans-serif; font-size:24px; z-index:1000; }
#loader-ok { margin-top:20px; font-size:32px; color:#0f0; opacity:0; transition:opacity 0.5s ease-in-out; }
.joystick { position:absolute; bottom:20px; left:20px; width:100px; height:100px; border-radius:50%; background:rgba(255,255,255,0.1); touch-action:none; }
.joystick-inner { position:absolute; width:50px; height:50px; border-radius:50%; background:rgba(255,255,255,0.3); top:25px; left:25px; pointer-events:none; }
.btn { position:absolute; width:60px; height:60px; border-radius:50%; background:rgba(255,255,255,0.2); text-align:center; line-height:60px; font-weight:bold; color:white; touch-action:none; }
.btn.up { bottom:100px; right:20px; }
.btn.down { bottom:20px; right:20px; }
#log { position:fixed; left:8px; top:8px; max-width:40%; max-height:40%; overflow:auto; background:rgba(0,0,0,0.6); padding:8px; border-radius:6px; font-size:12px; color:#ddd; display:none; z-index:1001; }
</style>
</head>
<body>
<div id="loader">Chargement des ressources...<div id="loader-ok">✔ OK</div></div>
<div id="log"></div>
<div class="joystick" id="joystick"><div class="joystick-inner" id="joyInner"></div></div>
<div class="btn up" id="btnUp">↑</div>
<div class="btn down" id="btnDown">↓</div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
const moduleCode = `
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
export function assembleShip(opts={}) {
  const colorBody = opts.colorBody ?? 0xff5555;
  const colorGlass = opts.colorGlass ?? 0x3333ff;
  const group = new THREE.Group();
  const bodyMat = new THREE.MeshStandardMaterial({ color: colorBody, metalness: 0.6, roughness: 0.25 });
  const body = new THREE.Mesh(new THREE.ConeGeometry(0.6, 2.2, 24), bodyMat);
  body.rotation.x = Math.PI / 2;
  group.add(body);
  const glassMat = new THREE.MeshPhysicalMaterial({ color: colorGlass, metalness: 0.1, roughness: 0.2, transmission: 0.6, transparent: true, opacity: 0.95, clearcoat: 0.2 });
  const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.42, 18, 18), glassMat);
  cockpit.position.set(0, 0.45, 0.6);
  group.add(cockpit);
  const wingMat = bodyMat.clone();
  const wingL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.5, 1.2), wingMat);
  wingL.position.set(-0.9, 0, -0.2);
  wingL.rotation.z = 0.06;
  const wingR = wingL.clone();
  wingR.position.set(0.9, 0, -0.2);
  group.add(wingL, wingR);
  const fin = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.6, 0.8), wingMat);
  fin.position.set(0, -0.6, -0.2);
  fin.rotation.x = 0.18;
  group.add(fin);
  const engineMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
  const thrusterL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.5, 12), engineMat);
  thrusterL.rotation.x = Math.PI / 2;
  thrusterL.position.set(-0.35, -1.05, 0);
  const thrusterR = thrusterL.clone();
  thrusterR.position.set(0.35, -1.05, 0);
  group.add(thrusterL, thrusterR);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9 });
  const ringL = new THREE.Mesh(new THREE.TorusGeometry(0.16, 0.03, 8, 32), ringMat);
  ringL.rotation.x = Math.PI / 2;
  ringL.position.copy(thrusterL.position);
  const ringR = ringL.clone();
  ringR.position.copy(thrusterR.position);
  group.add(ringL, ringR);
  const exhaustCount = 60;
  const exhaustPos = new Float32Array(exhaustCount * 3);
  for (let i = 0; i < exhaustCount; i++) {
    exhaustPos[i * 3 + 0] = (Math.random() - 0.5) * 0.2;
    exhaustPos[i * 3 + 1] = -1.4 - Math.random() * 0.6;
    exhaustPos[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
  }
  const exhaustGeom = new THREE.BufferGeometry();
  exhaustGeom.setAttribute('position', new THREE.BufferAttribute(exhaustPos, 3));
  const exhaustMat = new THREE.PointsMaterial({ color: 0xffaa66, size: 0.08, transparent: true, opacity: 0.9, depthWrite: false });
  const exhaust = new THREE.Points(exhaustGeom, exhaustMat);
  group.add(exhaust);
  const light1 = new THREE.PointLight(0xffaa66, 0.6, 6);
  light1.position.set(-0.35, -1.05, 0);
  const light2 = light1.clone();
  light2.position.set(0.35, -1.05, 0);
  group.add(light1, light2);
  group.userData = {
    setColor(bodyColor, glassColor) {
      bodyMat.color.set(bodyColor);
      glassMat.color.set(glassColor);
    },
    setThrusterPower(p) {
      const power = Math.max(0, Math.min(1, p));
      exhaustMat.size = 0.04 + power * 0.18;
      exhaustMat.opacity = 0.25 + power * 0.75;
      light1.intensity = 0.2 + power * 1.2;
      light2.intensity = 0.2 + power * 1.2;
      ringMat.opacity = 0.2 + power * 0.8;
    },
    updateExhaust() {
      const arr = exhaustGeom.attributes.position.array;
      for (let i = 0; i < arr.length / 3; i++) {
        const idx = i * 3;
        arr[idx + 0] += (Math.random() - 0.5) * 0.002;
        arr[idx + 1] -= 0.002 - Math.random() * 0.004;
        arr[idx + 2] += (Math.random() - 0.5) * 0.002;
        if (arr[idx + 1] < -2.2) arr[idx + 1] = -1.4 - Math.random() * 0.6;
      }
      exhaustGeom.attributes.position.needsUpdate = true;
    }
  };
  return group;
}
`;
const blob = new Blob([moduleCode], { type: 'text/javascript' });
const moduleUrl = URL.createObjectURL(blob);
const mod = await import(moduleUrl);
URL.revokeObjectURL(moduleUrl);
const logEl = document.getElementById('log');
function log(...a){ logEl.style.display='block'; logEl.innerHTML += '<div>'+a.map(x=>typeof x==='object'?JSON.stringify(x):String(x)).join(' ')+'</div>'; logEl.scrollTop = logEl.scrollHeight; }
const loaderDiv = document.getElementById('loader');
const okDiv = document.getElementById('loader-ok');
const textureUrls = {
  earth:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
  earth_clouds:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
  earth_specular:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg',
  earth_normal:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_normal_2048.jpg',
  moon:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg'
};
const textures = {};
const texLoader = new THREE.TextureLoader();
const promises = [];
for(const key in textureUrls){
  promises.push(new Promise(res=>{ texLoader.load(textureUrls[key], tex=>{ textures[key]=tex; res(); }, undefined, ()=>res()); }));
}
await Promise.all(promises);
okDiv.style.opacity='1';
await new Promise(r=>setTimeout(r,500));
loaderDiv.style.display='none';
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000010);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
camera.position.set(0,5,15);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const ambient = new THREE.AmbientLight(0x666666); scene.add(ambient);
const sunLight = new THREE.PointLight(0xffffff,2,0,2); sunLight.position.set(0,0,0); scene.add(sunLight);
const sun = new THREE.Mesh(new THREE.SphereGeometry(8,32,32), new THREE.MeshBasicMaterial({color:0xffffcc})); scene.add(sun);
const earthGeom = new THREE.SphereGeometry(5,64,64);
const earthMat = new THREE.MeshPhongMaterial({map:textures['earth']||null, specularMap:textures['earth_specular']||null, normalMap:textures['earth_normal']||null, shininess:5});
const earth = new THREE.Mesh(earthGeom, earthMat); earth.position.set(50,0,0); scene.add(earth);
const cloudMat = new THREE.MeshPhongMaterial({map:textures['earth_clouds']||null, transparent:true, depthWrite:false});
const clouds = new THREE.Mesh(new THREE.SphereGeometry(5.05,64,64), cloudMat); earth.add(clouds);
const moon = new THREE.Mesh(new THREE.SphereGeometry(1.3,32,32), new THREE.MeshPhongMaterial({map:textures['moon']||null})); moon.position.set(8,0,0); earth.add(moon);
(function(){const g=new THREE.BufferGeometry();const n=2000;const pos=new Float32Array(n*3);for(let i=0;i<n;i++){pos[i*3]=(Math.random()-0.5)*2000;pos[i*3+1]=(Math.random()-0.5)*2000;pos[i*3+2]=(Math.random()-0.5)*2000;}g.setAttribute('position',new THREE.BufferAttribute(pos,3));scene.add(new THREE.Points(g,new THREE.PointsMaterial({color:0x99ddff,size:4,transparent:true,opacity:0.8})));})();
let ship = mod.assembleShip({ colorBody: 0xff5555, colorGlass: 0x3333ff });
ship.position.set(0,0,0);
scene.add(ship);
let move={x:0,y:0,up:false,down:false};
const joy=document.getElementById('joystick'); const joyInner=document.getElementById('joyInner');
joy.addEventListener('touchstart',e=>e.preventDefault());
joy.addEventListener('touchmove',e=>{const t=e.touches[0]; const r=joy.getBoundingClientRect(); move.x=Math.max(-1,Math.min(1,(t.clientX-(r.left+r.width/2))/(r.width/2))); move.y=Math.max(-1,Math.min(1,-(t.clientY-(r.top+r.height/2))/(r.height/2))); joyInner.style.transform=\`translate(\${move.x*25}px, \${-move.y*25}px)\`;});
joy.addEventListener('touchend',()=>{move.x=0; move.y=0; joyInner.style.transform='translate(0,0)';});
document.getElementById('btnUp').addEventListener('touchstart',()=> move.up=true);
document.getElementById('btnUp').addEventListener('touchend',()=> move.up=false);
document.getElementById('btnDown').addEventListener('touchstart',()=> move.down=true);
document.getElementById('btnDown').addEventListener('touchend',()=> move.down=false);
let velocity=new THREE.Vector3(); let direction=new THREE.Vector3(); const forward=new THREE.Vector3(0,0,-1);
function animate(){requestAnimationFrame(animate);
  const t = Date.now()*0.00005;
  earth.position.x = 50 * Math.cos(t);
  earth.position.z = 50 * Math.sin(t);
  clouds.rotation.y += 0.0006;
  moon.rotation.y += 0.0012;
  direction.set(0,0,0);
  const localForward = forward.clone().applyEuler(ship.rotation);
  direction.add(localForward.multiplyScalar(move.y*0.25));
  if(move.up) direction.y += 0.12;
  if(move.down) direction.y -= 0.12;
  velocity.lerp(direction,0.08);
  ship.position.add(velocity);
  ship.rotation.y -= move.x*0.04;
  const thrusterPower = Math.min(1, Math.abs(move.y));
  if (ship && ship.userData && ship.userData.setThrusterPower) ship.userData.setThrusterPower(thrusterPower);
  if (ship && ship.userData && ship.userData.updateExhaust) ship.userData.updateExhaust();
  const desiredCam = ship.position.clone().add(new THREE.Vector3(0,3,8).applyEuler(ship.rotation));
  camera.position.lerp(desiredCam,0.12);
  camera.lookAt(ship.position);
  renderer.render(scene,camera);
}
animate();
window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);});
</script>
</body>
</html>
