<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Space — Flat Ship, Wormholes, 2 Galaxies & Black Holes</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<style>
  html,body{margin:0;height:100%;background:#000;user-select:none;overflow:hidden}
  canvas{display:block}
  #hud{position:fixed;left:12px;top:12px;color:#fff;font-family:system-ui,Arial;z-index:99;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px}
  .joystick{position:fixed;left:12px;bottom:12px;width:100px;height:100px;border-radius:50%;background:rgba(255,255,255,0.06);touch-action:none;z-index:99}
  .joystick-inner{width:50px;height:50px;border-radius:50%;background:rgba(255,255,255,0.18);position:relative;left:25px;top:25px;pointer-events:none}
  .btn{position:fixed;right:12px;width:60px;height:60px;border-radius:50%;background:rgba(255,255,255,0.08);text-align:center;line-height:60px;color:#fff;z-index:99}
  .btn.up{bottom:92px}.btn.down{bottom:12px}
  #galaxyLabel{position:fixed;left:50%;transform:translateX(-50%);top:12px;color:#fff;padding:6px 10px;background:rgba(0,0,0,0.35);border-radius:6px;font-family:system-ui,Arial;z-index:99}
</style>
</head>
<body>
<div id="hud">Vitesse: <span id="speed">0</span> m/s · Proche: <span id="near">—</span></div>
<div id="galaxyLabel">Galaxie 1</div>
<div class="joystick" id="joystick"><div class="joystick-inner" id="joyInner"></div></div>
<div class="btn up" id="btnUp">↑</div>
<div class="btn down" id="btnDown">↓</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';

/* =========================
   Helpers & configuration
   ========================= */
const hudSpeed = document.getElementById('speed');
const hudNear  = document.getElementById('near');
const galaxyLabel = document.getElementById('galaxyLabel');

const texLoader = new THREE.TextureLoader();
const loadSafe = url => new Promise(r=>texLoader.load(url,t=>r(t),undefined,()=>r(null)));

function makeStarSprite(s=128){
  const c=document.createElement('canvas'); c.width=c.height=s;
  const ctx=c.getContext('2d');
  const g=ctx.createRadialGradient(s/2,s/2,1,s/2,s/2,s/2);
  g.addColorStop(0,'rgba(255,255,255,1)');
  g.addColorStop(0.25,'rgba(170,200,255,0.95)');
  g.addColorStop(0.6,'rgba(120,160,255,0.35)');
  g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,s,s);
  const tex=new THREE.CanvasTexture(c); tex.minFilter=THREE.LinearFilter; return tex;
}

/* =========================
   Scene, camera, renderer
   ========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000007);
const camera = new THREE.PerspectiveCamera(58, innerWidth/innerHeight, 0.1, 6e6);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0x666666));
const sunLight = new THREE.PointLight(0xffffff, 3.4, 0); sunLight.position.set(0,0,0); scene.add(sunLight);

/* =========================
   Stars & dust
   ========================= */
const starSprite = makeStarSprite();
function addStarLayer(count, rMin, rMax, size){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r=rMin+Math.random()*(rMax-rMin), th=Math.random()*Math.PI*2, ph=(Math.random()-0.5)*Math.PI;
    pos[3*i]=Math.cos(th)*Math.cos(ph)*r; pos[3*i+1]=Math.sin(ph)*r; pos[3*i+2]=Math.sin(th)*Math.cos(ph)*r;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const mat = new THREE.PointsMaterial({map:starSprite, size:size, transparent:true, opacity:0.9, depthWrite:false, blending:THREE.AdditiveBlending});
  const pts = new THREE.Points(geo, mat); scene.add(pts); return pts;
}
let farStars = addStarLayer(3500, 200000, 900000, 180);
let midStars = addStarLayer(1800, 60000, 200000, 60);

(function makeDust(){
  const N=7000, geo=new THREE.BufferGeometry(), arr=new Float32Array(N*3);
  for(let i=0;i<N;i++){ const r=30000+Math.random()*900000, th=Math.random()*Math.PI*2, ph=(Math.random()-0.5)*0.12;
    arr[3*i]=Math.cos(th)*Math.cos(ph)*r; arr[3*i+1]=Math.sin(ph)*r; arr[3*i+2]=Math.sin(th)*Math.cos(ph)*r;}
  geo.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const mat=new THREE.PointsMaterial({size:30,color:0xfff7ef,transparent:true,opacity:0.04,depthWrite:false,blending:THREE.AdditiveBlending});
  scene.add(new THREE.Points(geo,mat));
})();

/* =========================
   Textures for planets
   ========================= */
const texUrls = {
  mercury:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/mercury.jpg',
  venus:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/venus.jpg',
  earth:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
  moon:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg',
  mars:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/mars_1k_color.jpg',
  jupiter:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/jupiter.jpg',
  saturn:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/saturn.jpg',
  saturnRing:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/saturnringcolor.jpg',
  uranus:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/uranus.jpg',
  neptune:'https://rawcdn.githack.com/mrdoob/three.js/dev/examples/textures/planets/neptune.jpg'
};

/* =========================
   Galaxy builder (returns Group)
   ========================= */
async function buildGalaxy(seedIndex){
  const group = new THREE.Group();
  const scaleFactor = seedIndex===1 ? 1.0 : 1.25;
  const specs = [
    ['Mercury', 3000*scaleFactor, 60000*scaleFactor, texUrls.mercury],
    ['Venus',   6500*scaleFactor,110000*scaleFactor, texUrls.venus],
    ['Earth',   7200*scaleFactor,165000*scaleFactor, texUrls.earth],
    ['Moon',    1800*scaleFactor,38000*scaleFactor, texUrls.moon],
    ['Mars',    3600*scaleFactor,230000*scaleFactor, texUrls.mars],
    ['Jupiter',16000*scaleFactor,410000*scaleFactor, texUrls.jupiter],
    ['Saturn', 15200*scaleFactor,760000*scaleFactor, texUrls.saturn, texUrls.saturnRing],
    ['Uranus', 9800*scaleFactor,1200000*scaleFactor, texUrls.uranus],
    ['Neptune',9400*scaleFactor,1700000*scaleFactor, texUrls.neptune],
    ['Pluto',  1600*scaleFactor,2300000*scaleFactor, null]
  ];
  for(const s of specs){
    const [name, radius, dist, tex, ringTex] = s;
    const geom = new THREE.SphereGeometry(radius, 48, 48);
    const map = tex ? await loadSafe(tex) : null;
    const mat = new THREE.MeshStandardMaterial(map?{map, metalness:0.02, roughness:0.75}:{color:0x888888, metalness:0.03, roughness:0.8});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(dist + (Math.random()-0.5)*radius*0.4, (Math.random()-0.5)*radius*0.04, (Math.random()-0.5)*radius*0.4);
    mesh.userData = {name, radius, distance: dist, angle: Math.random()*Math.PI*2, speed: (0.000001 + Math.random()*0.000004)};
    group.add(mesh);
    if(ringTex){
      const rmap = await loadSafe(ringTex);
      const ring = new THREE.Mesh(new THREE.RingGeometry(radius*1.2, radius*2.2, 128), new THREE.MeshBasicMaterial({map:rmap, side:THREE.DoubleSide, transparent:true, opacity:0.9}));
      ring.rotation.x = Math.PI/2.2; ring.position.copy(mesh.position); group.add(ring); mesh.userData.ring = ring;
    }
  }
  // parent Moon to Earth if found
  const earth = group.children.find(c=>c.userData && c.userData.name==='Earth');
  const moon = group.children.find(c=>c.userData && c.userData.name==='Moon');
  if(earth && moon){
    moon.position.set(earth.userData.radius + (earth.userData.radius*3.8), 0, 0);
    earth.add(moon);
    moon.userData = {orbitSpeed:0.0012, dist: earth.userData.radius + (earth.userData.radius*3.8), angle:0};
  }
  return group;
}

/* =========================
   Build both galaxies
   ========================= */
let galaxyGroup1 = null, galaxyGroup2 = null;
(async ()=>{
  galaxyGroup1 = await buildGalaxy(1);
  galaxyGroup2 = await buildGalaxy(2);
  scene.add(galaxyGroup1);
  // galaxyGroup2 remains off until teleport
})();

/* =========================
   Ship (flat + rear turbos)
   ========================= */
function buildShip(){
  const g = new THREE.Group();
  const hull = new THREE.Mesh(new THREE.BoxGeometry(1200,80,2400), new THREE.MeshStandardMaterial({color:0x8b8f91, metalness:0.9, roughness:0.18}));
  hull.scale.set(1,0.18,1); hull.position.set(0,14,220); g.add(hull);
  const cockpit = new THREE.Mesh(new THREE.SphereGeometry(220,18,18), new THREE.MeshPhysicalMaterial({color:0x0b2a3d, transmission:0.6, transparent:true, opacity:0.92}));
  cockpit.position.set(0,86,760); g.add(cockpit);
  const turboM = new THREE.MeshStandardMaterial({color:0x1b1b1b, metalness:0.95, roughness:0.12});
  const turboL = new THREE.Mesh(new THREE.CylinderGeometry(120,140,480,20), turboM); turboL.rotation.x=Math.PI/2; turboL.position.set(-320,-40,-820);
  const turboR = turboL.clone(); turboR.position.set(320,-40,-820);
  g.add(turboL, turboR);
  // exhaust points
  const N=220; const arr=new Float32Array(N*3);
  for(let i=0;i<N;i++){ arr[3*i] = (Math.random()-0.5)*220; arr[3*i+1] = -60 - Math.random()*240; arr[3*i+2] = -1100 - Math.random()*420; }
  const pGeo = new THREE.BufferGeometry(); pGeo.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const pMat = new THREE.PointsMaterial({color:0xffa75f,size:40,transparent:true,opacity:0.95,depthWrite:false});
  const exhaust = new THREE.Points(pGeo,pMat); g.add(exhaust);
  g.userData.radius = 900; // collision radius
  return g;
}
const ship = buildShip();
ship.position.set(28000, 9000, 0);
scene.add(ship);

/* =========================
   Physics state & controls
   ========================= */
const state = {pos: ship.position.clone(), vel: new THREE.Vector3(), mass:1.0};
let move = {x:0,y:0,up:false,down:false};
const joy = document.getElementById('joystick'), joyInner = document.getElementById('joyInner');
joy.addEventListener('touchstart', e=>e.preventDefault());
joy.addEventListener('touchmove', e=>{
  const t=e.touches[0], r=joy.getBoundingClientRect();
  move.x = Math.max(-1, Math.min(1, (t.clientX - (r.left + r.width/2)) / (r.width/2)));
  move.y = Math.max(-1, Math.min(1, -(t.clientY - (r.top + r.height/2)) / (r.height/2)));
  joyInner.style.transform = `translate(${move.x*25}px, ${-move.y*25}px)`;
});
joy.addEventListener('touchend', ()=>{ move.x=0; move.y=0; joyInner.style.transform='translate(0,0)'; });
document.getElementById('btnUp').addEventListener('touchstart', ()=>move.up=true); document.getElementById('btnUp').addEventListener('touchend', ()=>move.up=false);
document.getElementById('btnDown').addEventListener('touchstart', ()=>move.down=true); document.getElementById('btnDown').addEventListener('touchend', ()=>move.down=false);
window.addEventListener('keydown', e=>{
  if(e.key==='w') move.y=1; if(e.key==='s') move.y=-1; if(e.key==='a') move.x=-1; if(e.key==='d') move.x=1;
  if(e.key==='ArrowUp') move.up=true; if(e.key==='ArrowDown') move.down=true;
});
window.addEventListener('keyup', e=>{
  if(['w','s'].includes(e.key)) move.y=0; if(['a','d'].includes(e.key)) move.x=0;
  if(e.key==='ArrowUp') move.up=false; if(e.key==='ArrowDown') move.down=false;
});

/* =========================
   Wormholes & black holes
   ========================= */
const wormholes = [];
function makeWormhole(pos, size=80000){
  const tor = new THREE.Mesh(new THREE.TorusGeometry(size, size*0.2, 24, 180), new THREE.MeshBasicMaterial({color:0x66ccff, transparent:true, opacity:0.65, blending:THREE.AdditiveBlending, side:THREE.DoubleSide}));
  tor.position.copy(pos); scene.add(tor);
  const N=3000; const arr=new Float32Array(N*3);
  for(let i=0;i<N;i++){ const r=Math.random()*size*0.85, a=Math.random()*Math.PI*2, z=(Math.random()-0.5)*size*1.6; arr[3*i]=Math.cos(a)*r; arr[3*i+1]=Math.sin(a)*r; arr[3*i+2]=z; }
  const pg = new THREE.BufferGeometry(); pg.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const pp = new THREE.Points(pg, new THREE.PointsMaterial({size:80,color:0xaaffff,transparent:true,opacity:0.95,depthWrite:false,blending:THREE.AdditiveBlending}));
  pp.position.copy(pos); scene.add(pp);
  wormholes.push({tor, funnel:pp, pos: pos.clone(), size});
  return wormholes[wormholes.length-1];
}
for(let i=0;i<7;i++){
  const a=Math.random()*Math.PI*2, d=(5e5 + Math.random()*1.2e6) * (i%2?1.0:1.5);
  const p=new THREE.Vector3(Math.cos(a)*d, (Math.random()-0.5)*1.6e5, Math.sin(a)*d);
  makeWormhole(p, 7e4 + Math.random()*5e4);
}

const blackHoles = [];
function makeBlackHole(pos, mass, radius){
  const bh = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), new THREE.MeshBasicMaterial({color:0x000000}));
  bh.position.copy(pos); scene.add(bh);
  const disc = new THREE.Mesh(new THREE.RingGeometry(radius*1.6, radius*4.0, 64), new THREE.MeshBasicMaterial({color:0x442266, transparent:true, opacity:0.5, side:THREE.DoubleSide}));
  disc.rotation.x=Math.PI/2; disc.position.copy(pos); scene.add(disc);
  blackHoles.push({pos:pos.clone(), mass, radius, mesh:bh});
}
makeBlackHole(new THREE.Vector3(-1.8e6, 0, -8e5), 6e13, 8e4);
makeBlackHole(new THREE.Vector3(2.2e6, -9e5, 1.6e6), 4e13, 6e4);

/* =========================
   Collision handling (prevents passing through planets)
   - resolves collisions for an active galaxy group
   ========================= */
function resolvePlanetCollisions(activeGalaxy){
  if(!activeGalaxy) return;
  const sr = ship.userData.radius;
  let nearest = null, nearestDist = Infinity;
  // iterate over children of the group
  activeGalaxy.traverse(child=>{
    if(!child.userData || !child.userData.radius) return;
    const worldPos = child.getWorldPosition(new THREE.Vector3());
    const pr = child.userData.radius;
    const d = state.pos.distanceTo(worldPos);
    if(d < pr + sr){
      // push ship out along normal
      const n = state.pos.clone().sub(worldPos).normalize();
      const pen = (pr + sr) - d + 1;
      state.pos.add(n.multiplyScalar(pen));
      // reflect/dampen velocity
      const vn = state.vel.dot(n);
      if(vn < 0){
        const refl = state.vel.clone().sub(n.multiplyScalar(vn*1.6));
        state.vel.copy(refl.multiplyScalar(0.28));
      } else {
        state.vel.multiplyScalar(0.2);
      }
    }
    if(d < nearestDist){ nearestDist = d; nearest = child; }
  });
  if(nearest && nearestDist < 6e5) hudNear.textContent = nearest.userData.name + ' (' + Math.floor(nearestDist).toLocaleString() + ' m)';
  else hudNear.textContent = '—';
}

/* =========================
   Teleport (swap visible galaxy)
   - teleportToGalaxy(targetIndex, destPos)
   ========================= */
let inGalaxy = 1;
function teleportToGalaxy(targetIndex, destPos){
  if(targetIndex===1){
    if(scene.children.includes(galaxyGroup2)) scene.remove(galaxyGroup2);
    if(!scene.children.includes(galaxyGroup1)) scene.add(galaxyGroup1);
    inGalaxy = 1; galaxyLabel.textContent = 'Galaxie 1';
  } else {
    if(scene.children.includes(galaxyGroup1)) scene.remove(galaxyGroup1);
    if(!scene.children.includes(galaxyGroup2)) scene.add(galaxyGroup2);
    inGalaxy = 2; galaxyLabel.textContent = 'Galaxie 2';
  }
  state.pos.copy(destPos);
  state.vel.set(0,0,0);
  flashScreen(240, 0x66ccff);
}

/* =========================
   Wormhole & black hole behavior
   ========================= */
function applyBlackHoles(dt){
  for(const b of blackHoles){
    const rVec = b.pos.clone().sub(state.pos);
    const r = Math.max(1, rVec.length());
    const strength = b.mass * 1e-24;
    const accMag = strength / (r*r);
    const acc = rVec.normalize().multiplyScalar(accMag);
    state.vel.add(acc.multiplyScalar(dt));
    if(r < b.radius * 0.88){
      const ejectDir = state.pos.clone().sub(b.pos).normalize();
      state.vel.copy(ejectDir.multiplyScalar(5e3 + Math.random()*6e3));
      state.pos.copy(b.pos.clone().add(ejectDir.multiplyScalar(b.radius*3 + 6e4)));
      flashScreen(350, 0xffddaa);
    }
  }
}

function handleWormholes(dt){
  for(const w of wormholes){
    w.tor.rotation.x += 0.0009; w.tor.rotation.y += 0.0007; w.funnel.rotation.y += 0.0009;
    const d = state.pos.distanceTo(w.pos);
    if(d < w.size * 2.4){
      const pull = w.pos.clone().sub(state.pos).normalize().multiplyScalar((w.size*2.4 - d) * 0.00006);
      state.vel.add(pull.multiplyScalar(dt*60));
      midStars.material.size = 60 + (w.size*2.4 - Math.min(d,w.size*2.4)) * 0.0008;
      midStars.material.opacity = 1.0;
      camera.fov = 58 + Math.sin(performance.now()*0.003 + d*0.00001) * Math.min(12, (w.size*1.8 - d) * 0.00012);
      camera.updateProjectionMatrix();
      if(d < w.size*0.6){
        const targetGalaxyIndex = (inGalaxy===1?2:1);
        const dest = wormholes[Math.floor(Math.random()*wormholes.length)];
        const destPos = dest.pos.clone().add(new THREE.Vector3((Math.random()-0.5)*dest.size*0.6, (Math.random()-0.5)*dest.size*0.4, (Math.random()-0.5)*dest.size*0.6));
        teleportToGalaxy(targetGalaxyIndex, destPos);
      }
    } else {
      midStars.material.size = 60;
      midStars.material.opacity = 0.9;
      camera.fov = 58; camera.updateProjectionMatrix();
    }
  }
}

/* =========================
   Camera helper
   ========================= */
const camOffset = new THREE.Vector3(0, 9000, 26000);
function updateCamera(){
  const worldOff = camOffset.clone().applyQuaternion(ship.quaternion);
  camera.position.copy(state.pos.clone().add(worldOff));
  camera.lookAt(state.pos.clone().add(new THREE.Vector3(0, 2400, 0)));
  camera.up.set(0,1,0);
}

/* =========================
   Flash overlay
   ========================= */
let overlay = null;
function flashScreen(ms=200, color=0xffffff){
  if(overlay){ camera.remove(overlay); overlay=null; }
  const quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.8}));
  camera.add(quad); overlay = quad;
  setTimeout(()=>{ if(overlay){ camera.remove(overlay); overlay=null; } }, ms);
}

/* =========================
   Main loop (physics preserved)
   - Only addition: resolvePlanetCollisions(activeGalaxy)
   ========================= */
const THRUST = 1.2e5;
const DAMP = 0.006;
const MAX_SPEED = 6e4;
let last = performance.now();

function loop(){
  const now = performance.now();
  const dt = Math.min(0.06, (now - last)/1000); last = now;

  // controls -> thrust vector (exactly as before)
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
  const up = new THREE.Vector3(0,1,0);
  let thrust = new THREE.Vector3();
  thrust.add(forward.clone().multiplyScalar(move.y * THRUST));
  if(move.up) thrust.add(up.clone().multiplyScalar(THRUST*0.6));
  if(move.down) thrust.add(up.clone().multiplyScalar(-THRUST*0.6));
  state.vel.add(thrust.multiplyScalar(dt / state.mass));
  state.vel.multiplyScalar(1 - Math.min(DAMP, dt*2));
  if(state.vel.length() > MAX_SPEED) state.vel.setLength(MAX_SPEED);

  // apply black holes gravity (unchanged)
  applyBlackHoles(dt);

  // integrate position (unchanged physics)
  state.pos.add(state.vel.clone().multiplyScalar(dt));

  // --- NEW: prevent passing through planets (collision resolution)
  const activeGalaxy = (inGalaxy === 1 ? galaxyGroup1 : galaxyGroup2);
  if(activeGalaxy) resolvePlanetCollisions(activeGalaxy);

  // wormhole interactions
  handleWormholes(dt);

  // update visible galaxy orbits
  const activeGroup = (inGalaxy === 1 ? galaxyGroup1 : galaxyGroup2);
  if(activeGroup){
    activeGroup.children.forEach(obj=>{
      if(!obj.userData || !obj.userData.speed) return;
      obj.userData.angle += obj.userData.speed * dt * 60;
      const a = obj.userData.angle;
      const d = obj.userData.distance;
      obj.position.x = Math.cos(a) * d;
      obj.position.z = Math.sin(a) * d;
      if(obj.userData.ring) obj.userData.ring.position.copy(obj.position);
      obj.rotation.y += 0.0001;
    });
    // moon local orbit if parented
    const earth = activeGroup.children.find(c=>c.userData && c.userData.name==='Earth');
    if(earth){
      const moon = earth.children.find(c=>c.userData && c.userData.orbitSpeed);
      if(moon){ moon.userData.angle = (moon.userData.angle || 0) + moon.userData.orbitSpeed * dt * 60; moon.position.x = Math.cos(moon.userData.angle) * moon.userData.dist; moon.position.z = Math.sin(moon.userData.angle) * moon.userData.dist; }
    }
  }

  // update ship transform & small banking visual
  ship.position.copy(state.pos);
  ship.rotation.y -= move.x * 0.006;
  ship.rotation.z = -move.x * 0.04;

  // camera locked behind ship
  updateCamera();

  // HUD
  hudSpeed.textContent = Math.floor(state.vel.length()).toLocaleString();

  // render
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
loop();

/* =========================
   Initial orientation, resize, debug
   ========================= */
ship.lookAt(new THREE.Vector3(0,0,-1));
window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
window.addEventListener('keydown', e=>{
  if(e.key.toLowerCase()==='r'){ state.pos.set(28000,9000,0); state.vel.set(0,0,0); }
  if(e.key.toLowerCase()==='g'){ if(wormholes[0]) state.pos.copy(wormholes[0].pos.clone().add(new THREE.Vector3(0, wormholes[0].size*0.3, 0))); state.vel.set(0,0,0); }
  if(e.key.toLowerCase()==='b'){ if(blackHoles[0]) state.pos.copy(blackHoles[0].pos.clone().add(new THREE.Vector3(blackHoles[0].radius*3,0,blackHoles[0].radius*3))); state.vel.set(0,0,0); }
});

</script>
</body>
</html>
