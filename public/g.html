<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pilote Spatial — Solar System Explorer (fix imports)</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#ddd;-webkit-user-select:none;user-select:none;font-family:Inter,system-ui,Arial;}
  #app{width:100%;height:100%;overflow:hidden;position:relative;}
  canvas{display:block}
  #hud{position: absolute; left:12px; top:12px; padding:10px 12px; border-radius:8px; background: linear-gradient(180deg, rgba(0,0,0,0.35), rgba(0,0,0,0.18)); backdrop-filter: blur(6px); color:#cfe; font-size:13px;}
  #instr{position:absolute; right:12px; bottom:12px; background:rgba(0,0,0,0.22); padding:10px;border-radius:8px;max-width:360px;font-size:13px;}
  #btnView{margin-top:6px;padding:6px 10px;border-radius:6px;border:0;background:#116; color:#cfe;cursor:pointer}
  .small{font-size:12px;color:#9db;}
</style>
</head>
<body>
<div id="app"></div>
<div id="hud">
  <div><b id="mode">Mode</b> : <span id="modeVal">Pilote</span></div>
  <div>Vitesse : <span id="speed">0</span> km/s</div>
  <div>Distance cible : <span id="dist">—</span> km</div>
  <button id="btnView">Vue système / Rapprocher</button>
  <div class="small">C pour changer la vue • R pour recentrer • Click pour pointer-lock</div>
</div>
<div id="instr">
  <div><b>Commandes</b></div>
  <div>W/S : accélérer / frein • A/D : strafe • Q/E : roll</div>
  <div>Souris : regarder • Shift : descendre • Space : monter</div>
  <div class="small">Esc pour relâcher le pointeur</div>
</div>

<script type="module">
/* Imports using full CDN URLs (UNPKG) to avoid "does not resolve" errors */
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/PointerLockControls.js';
import { EffectComposer } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';

/* ---------- Scene & renderer ---------- */
const container = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000010);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1e8);
camera.position.set(0, 10, 40);

/* Composer + bloom */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.9, 0.6, 0.1);
bloom.threshold = 0.2; bloom.strength = 1.4; bloom.radius = 0.7;
composer.addPass(bloom);

/* Lights */
scene.add(new THREE.AmbientLight(0xaaaaaa, 0.08));

/* Stars */
(function makeStars(count=6000, radius=20000){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const col = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r = radius * (0.6 + Math.random()*0.4);
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);
    pos[i*3]=Math.sin(phi)*Math.cos(theta)*r;
    pos[i*3+1]=Math.sin(phi)*Math.sin(theta)*r;
    pos[i*3+2]=Math.cos(phi)*r;
    const t = Math.random()*0.8 + 0.2;
    col[i*3]=t; col[i*3+1]=t; col[i*3+2]=t;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color', new THREE.BufferAttribute(col,3));
  const mat = new THREE.PointsMaterial({ size: 30, vertexColors:true, transparent:true, opacity:0.9, depthWrite:false });
  scene.add(new THREE.Points(geo, mat));
})();

/* Sun */
const SUN_RADIUS = 696340;
const scale = 0.00005;
const sunGeo = new THREE.SphereGeometry(SUN_RADIUS*scale, 64, 64);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, toneMapped:false });
const sunMesh = new THREE.Mesh(sunGeo, sunMat);
sunMesh.layers.enable(1);
scene.add(sunMesh);
const sunLight = new THREE.PointLight(0xfff1cc, 4.5, 0, 2);
sunLight.position.copy(sunMesh.position);
scene.add(sunLight);
const glow = new THREE.Sprite(new THREE.SpriteMaterial({color:0xffeeaa, opacity:0.9, blending:THREE.AdditiveBlending}));
glow.scale.setScalar(SUN_RADIUS*scale*6);
sunMesh.add(glow);

/* Planets dataset */
const planetsData = [
  { name:'Mercure', color:0x9b9b9b, size: 2439, dist:57.9, orbitalPeriod:88 },
  { name:'Vénus',  color:0xe0b57f, size:6052, dist:108.2, orbitalPeriod:225 },
  { name:'Terre',  color:0x2a66d9, size:6371, dist:149.6, orbitalPeriod:365 },
  { name:'Mars',   color:0xd65a3b, size:3389, dist:227.9, orbitalPeriod:687 },
  { name:'Jupiter',color:0xd6b08a, size:69911, dist:778.6, orbitalPeriod:4331 },
  { name:'Saturne',color:0xe6cfa3, size:58232, dist:1433.5, orbitalPeriod:10747 },
  { name:'Uranus', color:0x99dff0, size:25362, dist:2872.5, orbitalPeriod:30589 },
  { name:'Neptune',color:0x3b6bd6, size:24622, dist:4495.1, orbitalPeriod:59800 }
];

const DIST_SCALE = 900 / 4500;
const PLANET_SCALE = 0.03;
const planetGroup = new THREE.Group();
scene.add(planetGroup);
const planets = [];

for(let i=0;i<planetsData.length;i++){
  const p = planetsData[i];
  const distScene = p.dist * DIST_SCALE;
  const radiusScene = Math.max(1.2, p.size * PLANET_SCALE * 0.001);
  const geom = new THREE.SphereGeometry(radiusScene, 32, 32);
  const mat = new THREE.MeshStandardMaterial({ color: p.color, metalness:0.05, roughness:0.8 });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.set(distScene, 0, 0);
  mesh.userData = { idx:i, data:p, radiusScene };
  planetGroup.add(mesh);
  planets.push(mesh);
  const curve = new THREE.RingGeometry(distScene - 0.02, distScene + 0.02, 128);
  const cmat = new THREE.MeshBasicMaterial({ color:0x444466, side:THREE.DoubleSide, transparent:true, opacity:0.4 });
  const ring = new THREE.Mesh(curve, cmat);
  ring.rotation.x = Math.PI/2;
  scene.add(ring);
  // label
  const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=64;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,256,64);
  ctx.font='28px sans-serif'; ctx.fillStyle='#cfe'; ctx.fillText(p.name, 10,36);
  const tex = new THREE.CanvasTexture(canvas);
  const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map:tex, depthTest:false }));
  spr.scale.set(18,4.6,1);
  spr.position.copy(mesh.position).add(new THREE.Vector3(0, radiusScene+6, 0));
  scene.add(spr);
}

/* Asteroid belt */
(function makeAsteroidBelt(inner, outer, count=400){
  const g = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const r = inner + Math.random()*(outer-inner);
    const a = Math.random()*Math.PI*2;
    const y = (Math.random()-0.5)*6;
    pos[i*3]=Math.cos(a)*r; pos[i*3+1]=y; pos[i*3+2]=Math.sin(a)*r;
  }
  g.setAttribute('position', new THREE.BufferAttribute(pos,3));
  const m = new THREE.PointsMaterial({ size:1.6, color:0x9c9c9c, transparent:true, opacity:0.9 });
  scene.add(new THREE.Points(g,m));
})(270*DIST_SCALE, 360*DIST_SCALE, 1200);

/* Ship (camera parent) */
const ship = new THREE.Object3D();
ship.position.set(0, 2, -20);
scene.add(ship);
ship.add(camera);
camera.position.set(0, 2, 8);
camera.lookAt(ship.position);

let velocity = new THREE.Vector3();
let accel = new THREE.Vector3();
const MAX_SPEED = 500;
const ACCEL = 120;
const DRAG = 0.98;

const pointerControls = new PointerLockControls(ship, document.body);
const orbitControls = new OrbitControls(camera, renderer.domElement);
orbitControls.enabled = false; orbitControls.enableDamping = true; orbitControls.dampingFactor = 0.12;

const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if(e.key==='r'||e.key==='R') resetShip(); if(e.key==='c'||e.key==='C') toggleView(); });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

renderer.domElement.addEventListener('click', ()=> { if(!pointerLocked) pointerControls.lock(); });
let pointerLocked = false;
document.addEventListener('pointerlockchange', ()=> {
  pointerLocked = document.pointerLockElement === document.body;
  orbitControls.enabled = !pointerLocked && systemView;
});

/* HUD */
const modeEl = document.getElementById('modeVal');
const speedEl = document.getElementById('speed');
const distEl = document.getElementById('dist');
const btnView = document.getElementById('btnView');

let systemView = true;
let targetPlanet = null;

function toggleView(){
  systemView = !systemView;
  if(systemView){
    orbitControls.enabled = true;
    orbitControls.target.set(0,0,0);
    camera.position.set(0, 400, 900);
    orbitControls.update();
    modeEl.textContent = 'Vue Système';
    btnView.textContent = 'Passer en Pilotage';
  } else {
    orbitControls.enabled = false;
    pointerControls.lock();
    modeEl.textContent = 'Pilotage';
    btnView.textContent = 'Vue Système';
  }
}
btnView.addEventListener('click', toggleView);
function resetShip(){ ship.position.set(0,2,-50); velocity.set(0,0,0); ship.rotation.set(0,0,0); camera.position.set(0,2,8); }

toggleView();

/* double click to focus */
renderer.domElement.addEventListener('dblclick', ev=>{
  const mouse = new THREE.Vector2((ev.clientX / innerWidth) * 2 - 1, -(ev.clientY / innerHeight) * 2 + 1);
  const ray = new THREE.Raycaster();
  ray.setFromCamera(mouse, camera);
  const hits = ray.intersectObjects(planets, true);
  if(hits.length){ focusPlanet(hits[0].object); }
});
function focusPlanet(p){
  systemView = true;
  orbitControls.enabled = true;
  orbitControls.target.copy(p.position);
  const dist = p.userData.radiusScene * 18 + p.position.length()*0.02;
  camera.position.copy(p.position).add(new THREE.Vector3(dist, dist*0.35, dist*0.7));
  orbitControls.update();
  modeEl.textContent = 'Vue Planète';
  btnView.textContent = 'Passer en Pilotage';
  targetPlanet = p;
}

/* animation & orbits */
const TWO_PI = Math.PI*2;
let time = 0;
function updateOrbits(dt){
  time += dt * 0.05;
  for(let i=0;i<planets.length;i++){
    const p = planets[i];
    const data = p.userData.data;
    const period = data.orbitalPeriod;
    const speed = TWO_PI / Math.max(1, period);
    const ang = time * speed + i*0.3;
    const r = data.dist * DIST_SCALE;
    p.position.set(Math.cos(ang)*r, Math.sin(i*0.1+time*0.01)*3, Math.sin(ang)*r);
    p.rotation.y += 0.001 + (i*0.0004);
  }
}

let lastTime = performance.now();
function updateFlight(dt){
  if(systemView) return;
  const forward = (keys['w']?1:0) - (keys['s']?1:0);
  const right = (keys['d']?1:0) - (keys['a']?1:0);
  const up = (keys[' ']?1:0) - (keys['shift']?1:0);
  const roll = (keys['q']?1:0) - (keys['e']?1:0);
  const localForward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
  const localRight = new THREE.Vector3(1,0,0).applyQuaternion(ship.quaternion).normalize();
  const localUp = new THREE.Vector3(0,1,0).applyQuaternion(ship.quaternion).normalize();
  const thrustVec = localForward.clone().multiplyScalar(forward * ACCEL * dt);
  const strafeVec = localRight.clone().multiplyScalar(right * ACCEL * 0.6 * dt);
  const liftVec = localUp.clone().multiplyScalar(up * ACCEL * 0.6 * dt);
  accel.copy(thrustVec).add(strafeVec).add(liftVec);
  velocity.add(accel);
  velocity.multiplyScalar(Math.pow(DRAG, dt*60));
  if(velocity.length() > MAX_SPEED) velocity.setLength(MAX_SPEED);
  ship.rotateZ(-roll * dt * 1.5);
  ship.position.addScaledVector(velocity, dt);
  speedEl.textContent = (velocity.length() * 0.05).toFixed(1);
}

function adjustPlanetDetail(){
  for(const p of planets){
    const d = p.position.distanceTo(camera.position);
    const base = p.userData.radiusScene;
    const needHigh = d < base * 12;
    const segs = needHigh ? 64 : 24;
    if(!p.geometry.parameters || p.geometry.parameters.widthSegments !== segs){
      const newG = new THREE.SphereGeometry(base, segs, segs);
      p.geometry.dispose();
      p.geometry = newG;
    }
  }
}

function animate(){
  const now = performance.now();
  const dt = Math.min((now - lastTime)/1000, 0.05);
  lastTime = now;
  updateOrbits(dt);
  updateFlight(dt);
  adjustPlanetDetail();
  if(targetPlanet) distEl.textContent = Math.round(camera.position.distanceTo(targetPlanet.position));
  else distEl.textContent = '—';
  if(orbitControls.enabled) orbitControls.update();
  composer.render();
  requestAnimationFrame(animate);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight);
});

(function initialPlacement(){ camera.position.set(0, 400, 900); orbitControls.update(); })();

</script>
</body>
</html>
