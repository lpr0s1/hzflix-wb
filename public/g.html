<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Space Pilot — système solaire réel</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    /* Loader overlay */
    #loader {
      position: absolute; top:0; left:0; width:100%; height:100%;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column; background: #000; color: #ddd;
      font-family: sans-serif; font-size: 22px;
    }
    #loader span {
      margin-top: 20px; font-size: 32px; color: #0f0;
      opacity: 0; transition: opacity 0.6s ease;
    }
    /* Controls (joystick + ascend/descend) */
    .joystick {
      position: absolute;
      bottom: 20px; left: 20px;
      width: 100px; height: 100px;
      border-radius: 50%;
      background: rgba(255,255,255,0.12);
      touch-action: none;
    }
    .joystick-inner {
      position: absolute;
      width: 50px; height: 50px;
      border-radius: 50%;
      background: rgba(255,255,255,0.25);
      top: 25px; left: 25px;
    }
    .btn {
      position: absolute;
      width: 60px; height: 60px;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      text-align: center;
      line-height: 60px;
      font-size: 24px;
      color: white;
      user-select: none;
    }
    .btn.up { bottom: 100px; right: 20px; }
    .btn.down { bottom: 20px; right: 20px; }
  </style>
</head>
<body>

  <div id="loader">Chargement des ressources...<span id="loader-ok">✔ OK</span></div>

  <!-- Touch controls -->
  <div class="joystick" id="joystick"><div class="joystick-inner" id="joyInner"></div></div>
  <div class="btn up" id="btnUp">↑</div>
  <div class="btn down" id="btnDown">↓</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
  (async function(){
    const loaderDiv = document.getElementById('loader');
    const okSpan = document.getElementById('loader-ok');

    // --- Données planètes + textures publiques ---
    const planetDefs = [
      { name: 'Mercury', url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/planets/mercury.jpg', size: 2.4, orbit: 20, speed: 0.0015 },
      { name: 'Venus',   url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/planets/venus.jpg',   size: 6.1, orbit: 30, speed: 0.0012 },
      { name: 'Earth',   url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/planets/earth_atmos_2048.jpg', size: 6.4, orbit: 40, speed: 0.0010 },
      { name: 'Mars',    url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/planets/mars.jpg',    size: 3.4, orbit: 55, speed: 0.0008 },
      { name: 'Jupiter', url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/planets/jupiter.jpg', size: 11.2, orbit: 80, speed: 0.0004 },
      { name: 'Saturn',  url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/planets/saturn.jpg',  size: 9.4, orbit: 100, speed: 0.0003 },
      { name: 'Uranus',  url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/planets/uranus.jpg',  size: 4.0, orbit: 120, speed: 0.0002 },
      { name: 'Neptune', url: 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r152/examples/textures/planets/neptune.jpg', size: 3.9, orbit: 140, speed: 0.00015 }
    ];

    const textureLoader = new THREE.TextureLoader();
    const planets = [];

    // Charge toutes les textures avant de commencer
    for (const def of planetDefs) {
      try {
        const tex = await new Promise((res, rej) => {
          textureLoader.load(def.url, res, undefined, rej);
        });
        planets.push({ def, texture: tex });
      } catch(e) {
        console.warn('Texture failed to load for', def.name, e);
      }
    }

    // Indicateur OK
    okSpan.style.opacity = 1;
    await new Promise(r => setTimeout(r, 500));
    loaderDiv.style.display = 'none';

    // --- Initialisation scène ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000011);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0, 5, 25);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lumières
    scene.add(new THREE.AmbientLight(0x555555));
    const sunLight = new THREE.PointLight(0xffffff, 2, 0, 2);
    sunLight.position.set(0,0,0);
    scene.add(sunLight);

    // Soleil
    const sun = new THREE.Mesh(
      new THREE.SphereGeometry(5, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0xffffaa })
    );
    scene.add(sun);

    // Création des planètes
    const planetMeshes = [];
    planets.forEach(p => {
      const mat = new THREE.MeshPhongMaterial({ map: p.texture });
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(p.def.size, 32, 32),
        mat
      );
      mesh.userData = { orbit: p.def.orbit, angle: Math.random()*Math.PI*2, speed: p.def.speed };
      mesh.position.set(p.def.orbit, 0, 0);
      scene.add(mesh);
      planetMeshes.push(mesh);
    });

    // Étoiles d’arrière-plan
    (function makeStars(n=2000, radius=2000){
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(n*3);
      for(let i=0;i<n;i++){
        const r = radius * (0.6 + Math.random()*0.4);
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(2*Math.random()-1);
        pos[i*3]   = Math.sin(phi)*Math.cos(theta)*r;
        pos[i*3+1] = Math.sin(phi)*Math.sin(theta)*r;
        pos[i*3+2] = Math.cos(phi)*r;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      const pts = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xaaaaaa, size: 8, transparent:true, opacity:0.8, depthWrite:false }));
      scene.add(pts);
    })();

    // Vaisseau (caméra parent)
    const ship = new THREE.Object3D();
    ship.position.set(0,0,0);
    scene.add(ship);
    ship.add(camera);
    camera.position.set(0,2,8);

    // Contrôles tactiles
    const joy = document.getElementById('joystick');
    const joyInner = document.getElementById('joyInner');
    let move = { x:0, y:0, up:false, down:false };

    joy.addEventListener('touchstart', e => e.preventDefault(), { passive:false });
    joy.addEventListener('touchmove', e => {
      const t = e.touches[0];
      const r = joy.getBoundingClientRect();
      const dx = t.clientX - (r.left + r.width/2);
      const dy = t.clientY - (r.top + r.height/2);
      const m = r.width/2;
      move.x = Math.max(-1, Math.min(1, dx/m));
      move.y = Math.max(-1, Math.min(1, -dy/m));
      joyInner.style.transform = `translate(${move.x*25}px, ${-move.y*25}px)`;
    }, { passive:false });
    joy.addEventListener('touchend', e => {
      move.x = 0; move.y = 0;
      joyInner.style.transform = 'translate(0,0)';
    });

    document.getElementById('btnUp').addEventListener('touchstart', ()=>move.up = true);
    document.getElementById('btnUp').addEventListener('touchend',   ()=>move.up = false);
    document.getElementById('btnDown').addEventListener('touchstart', ()=>move.down = true);
    document.getElementById('btnDown').addEventListener('touchend',   ()=>move.down = false);

    // Animation loop
    let velocity = new THREE.Vector3();
    function animate(){
      requestAnimationFrame(animate);

      // Orbites planètes
      planetMeshes.forEach(m => {
        m.userData.angle += m.userData.speed;
        m.position.set(
          Math.cos(m.userData.angle) * m.userData.orbit,
          0,
          Math.sin(m.userData.angle) * m.userData.orbit
        );
        m.rotation.y += 0.002;
      });

      // Pilotage vaisseau
      const thrust = 0.25, rot = 0.06;
      ship.rotation.z -= move.x * rot;
      ship.rotation.x -= move.y * rot;
      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
      velocity.add(forward.multiplyScalar(move.y * thrust));
      if (move.up)   velocity.y += thrust * 0.5;
      if (move.down) velocity.y -= thrust * 0.5;
      ship.position.add(velocity);
      velocity.multiplyScalar(0.94);

      // Caméra suit vaisseau
      camera.position.lerp(ship.position.clone().add(new THREE.Vector3(0,2,8).applyQuaternion(ship.quaternion)), 0.1);
      camera.lookAt(ship.position);

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  })();
  </script>
</body>
</html>
