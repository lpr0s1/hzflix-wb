<!DOCTYPE html>
<html lang="fr">
  <head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5349978344944379"
     crossorigin="anonymous"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="HZFlix - Plateforme de streaming en ligne proposant des films et séries"
    />
    <title>HZFlix - Streaming de Films et Séries</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    
    <!-- Préchargement des ressources critiques -->
    <link rel="preload" href="js/config.js" as="script" />
    <link rel="preload" href="js/utils.js" as="script" />
  </head>
  <body>
    <header>
      <nav>
        <div class="logo">
          <h1>HZFlix</h1>
        </div>
        <ul class="nav-links">
          <li><a href="#" data-section="home" class="active">Accueil</a></li>
          <li><a href="#" data-section="series">Séries</a></li>
          <li><a href="#" data-section="movies">Films</a></li>
          <li><a href="#" data-section="mylist">Ma Liste</a></li>
        </ul>
        <div class="search-container">
          <input
            type="text"
            id="searchInput"
            placeholder="Rechercher un film..."
          />
          <button id="searchButton">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
            >
              <circle cx="11" cy="11" r="8"></circle>
              <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            </svg>
          </button>
        </div>
      </nav>
    </header>

    <main>
      <section class="hero">
        <div class="featured-content">
          <h2>Film à la une</h2>
          <p class="description">
            Description du film en vedette qui capture l'attention des
            utilisateurs.
          </p>
          <div class="buttons">
            <button class="play-btn">Lecture</button>
            <button class="info-btn">Plus d'infos</button>
          </div>
        </div>
      </section>

      <section class="trending">
        <h3>Tendances actuelles</h3>
        <div class="movie-row"></div>
      </section>

      <section class="popular">
        <h3>Populaire sur HZFlix</h3>
        <div class="movie-row"></div>
      </section>

      <section class="continue-watching">
        <h3>Continuer à regarder</h3>
        <div class="movie-row"></div>
      </section>
    </main>

    <footer>
      <p>&copy; 2025 HZFlix. Tous droits réservés.</p>
    </footer>

    
<style>
  /* Reset et styles de base */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "Poppins", sans-serif;
  background-color: #141414;
  color: #fff;
}

/* Header et Navigation */
header {
  position: fixed;
  top: 0;
  width: 100%;
  padding: 1rem 4%;
  z-index: 1000;
  transition: all 0.3s ease;
  background: transparent;
}

header.scrolled {
  background: rgba(20, 20, 20, 0.8);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
}

nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.logo h1 {
  color: #e50914;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: -0.5px;
  user-select: none;
}

.nav-links {
  display: flex;
  list-style: none;
  gap: 2rem;
  user-select: none;
}

.nav-links a {
  color: #fff;
  text-decoration: none;
  font-size: 1rem;
  font-weight: 500;
  letter-spacing: 0.3px;
  transition: all 0.3s ease;
  position: relative;
  padding-bottom: 2px;
}

.nav-links a::after {
  content: "";
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 0;
  height: 2px;
  background-color: #e50914;
  transition: width 0.3s ease;
}

.nav-links a:hover::after,
.nav-links a.active::after {
  width: 100%;
}

.nav-links a:hover,
.nav-links a.active {
  color: #fff;
  font-weight: 600;
}

/* Section Hero */
.hero {
  height: 80vh;
  background-size: cover;
  display: flex;
  align-items: center;
  padding: 0 4%;
  margin-bottom: 2rem;
}

.featured-content {
  max-width: 600px;
}

.featured-content h2 {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.description {
  font-size: 1.2rem;
  margin-bottom: 2rem;
}

.buttons {
  display: flex;
  gap: 1rem;
}

.play-btn,
.info-btn {
  padding: 0.8rem 2rem;
  border: none;
  border-radius: 4px;
  font-size: 1.1rem;
  cursor: pointer;
  transition: all 0.3s ease;
  user-select: none;
}

.play-btn {
  background-color: #fff;
  color: #000;
}

.info-btn {
  background-color: rgba(109, 109, 110, 0.7);
  color: #fff;
}

.play-btn:hover {
  background-color: rgba(255, 255, 255, 0.75);
}

.info-btn:hover {
  background-color: rgba(109, 109, 110, 0.4);
}

/* Sections de contenu */
section {
  padding: 2rem 4%;
}

.series-section,
.movies-section,
.mylist-section {
  margin-top: 80px;
}

.search-results {
  margin-top: 120px; /* Marge augmentée pour éviter que le header ne masque le contenu */
}

section h3 {
  font-size: 1.5rem;
  margin-bottom: 1rem;
}

.movie-row {
  display: flex;
  overflow-x: auto;
  gap: 1rem;
  padding: 1rem 0;
}

.movie-row::-webkit-scrollbar {
  display: none;
}

/* Styles pour les cartes de films */
.movie-card {
  min-width: 200px;
  margin-right: 1rem;
  position: relative;
  transition: transform 0.3s ease;
  cursor: pointer;
  user-select: none;
}

.movie-card:hover {
  transform: scale(1.05);
}

.movie-card img {
  width: 100%;
  height: 300px;
  object-fit: cover;
  border-radius: 4px;
}

.movie-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 1rem;
  background: linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0));
  border-radius: 0 0 4px 4px;
}

.movie-info h4 {
  margin: 0;
  color: #fff;
  font-size: 1.1rem;
}

.movie-overview {
  display: none;
  margin-top: 0.5rem;
  font-size: 0.9rem;
  color: #ccc;
}

.movie-card:hover .movie-overview {
  display: block;
}

.progress-bar {
  height: 3px;
  background-color: #404040;
  margin-top: 0.5rem;
  border-radius: 2px;
}

.progress-bar > div {
  height: 100%;
  background-color: #e50914;
  border-radius: 2px;
}

/* Modal des détails du film */
.movie-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.9);
  display: flex;
  justify-content: center;
  align-items: flex-start; /* Changé de center à flex-start */
  z-index: 1100;
  opacity: 0;
  transition: opacity 0.3s ease;
  overflow-y: auto; /* Ajout du scroll sur le modal */
  padding: 20px;
}

.movie-modal.show {
  opacity: 1;
}

.movie-modal.closing {
  opacity: 0;
}

.modal-content {
  position: relative;
  width: 95%;
  max-width: 1200px;
  margin: 20px auto; /* Ajout de marges auto */
  background: #141414;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.modal-video-container {
  position: relative;
  padding-top: 56.25%;
  background: #000;
}

.modal-video-container iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.modal-backdrop {
  height: 400px;
  background-size: cover;
  background-position: center;
  position: relative;
}

.backdrop-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(to bottom, rgba(20, 20, 20, 0.2), #141414);
}

.modal-info {
  position: relative;
  min-height: 60vh; /* Ajout d'une hauteur minimale */
  height: auto;
  overflow-y: auto;
  padding: 32px;
  background: linear-gradient(
    to bottom,
    rgba(20, 20, 20, 1) 0%,
    rgba(20, 20, 20, 0.95) 100%
  );
}

.modal-header {
  margin-bottom: 24px;
}

.modal-body {
  padding: 0;
  min-height: 400px; /* Hauteur minimale pour le contenu */
}

.modal-close {
  position: absolute;
  top: 16px;
  right: 16px;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.6);
  border: none;
  color: white;
  font-size: 24px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.3s;
  z-index: 2;
}

.modal-close:hover {
  background: rgba(255, 255, 255, 0.2);
}

.modal-header h2 {
  font-size: 2.5rem;
  margin-bottom: 20px;
  font-weight: 700;
}

.modal-actions {
  display: flex;
  gap: 12px;
  margin-bottom: 24px;
}

.action-button {
  padding: 8px 24px;
  border-radius: 4px;
  border: none;
  font-size: 1.1rem;
  font-weight: 500;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.2s;
  user-select: none;
}

.action-button svg {
  width: 24px;
  height: 24px;
}

.play-button {
  background: #fff;
  color: #000;
}

.play-button:hover {
  background: rgba(255, 255, 255, 0.85);
}

.list-button {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
}

.list-button:hover {
  background: rgba(255, 255, 255, 0.2);
}

.list-button.in-list {
  background: #e50914;
}

.list-button svg {
  transition: transform 0.3s ease;
}

.list-button:hover svg {
  transform: scale(1.2);
}

.list-button.in-list svg {
  animation: check-animation 0.5s ease-out;
}

.movie-meta {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 12px;
  margin: 16px 0 24px;
}

.rating-container {
  display: inline-flex;
  align-items: center;
  padding: 4px 8px;
  background: rgba(255, 255, 255, 0.08);
  border-radius: 4px;
  height: 32px;
}

.meta-item {
  display: inline-flex;
  align-items: center;
  padding: 4px 12px;
  background: rgba(255, 255, 255, 0.08);
  border-radius: 4px;
  color: #fff;
  font-size: 0.95rem;
  height: 32px;
  white-space: nowrap;
}

.genres {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
  margin-left: auto;
}

.genre-tag {
  background: rgba(255, 255, 255, 0.1);
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 0.9rem;
}

.overview {
  font-size: 1.1rem;
  line-height: 1.8;
  color: #fff;
  margin-bottom: 32px;
}

/* Modal Info Styles */
.modal-info {
  position: relative;
  min-height: 60vh;
  height: auto;
  overflow-y: auto;
  padding: 32px;
  background: linear-gradient(
    to bottom,
    rgba(20, 20, 20, 1) 0%,
    rgba(20, 20, 20, 0.95) 100%
  );
}

.modal-header {
  margin-bottom: 24px;
}

/* Système d'étoiles amélioré */
.star-rating {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.stars {
  display: flex;
  align-items: center;
  gap: 4px;
}

.star {
  font-size: 20px;
  line-height: 1;
  position: relative;
  display: inline-block;
  color: #444;
  transition: color 0.2s ease;
  width: 20px;
  height: 20px;
  text-align: center;
}

.star.full {
  color: #ffd700;
}

.star.half {
  position: relative;
  overflow: hidden;
  color: #444;
}

.star.half::before {
  content: "★";
  position: absolute;
  left: 0;
  top: 0;
  width: 50%;
  overflow: hidden;
  color: #ffd700;
}

.star.empty {
  color: #444;
}

.rating-number {
  font-size: 16px;
  font-weight: 600;
  color: #ffd700;
  margin-left: 4px;
}

.rating-text {
  color: #ffd700;
  font-weight: 600;
  font-size: 1.1rem;
}

/* Cast Section */
.cast-section {
  margin: 40px 0;
}

.cast-section h3,
.recommendations-section h3 {
  font-size: 1.8rem;
  margin-bottom: 24px;
  color: #fff;
}

/* Recommendations Section */
.recommendations-section {
  margin-top: 40px;
}

.cast-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 20px;
  margin: 20px 0;
  overflow-x: hidden; /* Empêcher le défilement horizontal */
}

.cast-member {
  text-align: center;
}

.cast-photo {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  margin: 0 auto 12px;
  background-size: cover;
  background-position: center;
  background-color: #2a2a2a;
}

.actor-name {
  display: block;
  font-weight: 500;
  margin-bottom: 4px;
}

.character-name {
  display: block;
  font-size: 0.9rem;
  color: #999;
}

.recommendations-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 16px;
  padding: 8px;
  margin: -8px;
  overflow: visible;
}

.recommendation-item {
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  z-index: 1;
  user-select: none;
}

.recommendation-item:hover {
  transform: scale(1.05);
  z-index: 2;
}

.recommendation-poster {
  position: relative;
  padding-top: 150%;
  background-size: cover;
  background-position: center;
  border-radius: 4px;
  overflow: hidden;
  will-change: transform;
}

.recommendation-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 16px;
  background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));
  transform: translateY(100%);
  transition: transform 0.3s ease;
}

.recommendation-item:hover .recommendation-info {
  transform: translateY(0);
}

.rec-title {
  display: block;
  font-size: 1rem;
  font-weight: 500;
  margin-bottom: 8px;
}

.rec-rating {
  font-size: 0.9rem;
}

/* Styles pour la barre de recherche */
.search-container {
  display: flex;
  align-items: center;
  margin-left: 2rem;
}

#searchInput {
  background-color: rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.3);
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  margin-right: 0.5rem;
  width: 200px;
  transition: all 0.3s ease;
  font-family: "Poppins", sans-serif;
  font-weight: 400;
}

#searchInput:focus {
  background-color: rgba(0, 0, 0, 0.8);
  border-color: white;
  width: 300px;
  outline: none;
}

#searchButton {
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  padding: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

#searchButton:hover {
  color: #e50914;
}

/* Footer */
footer {
  text-align: center;
  padding: 2rem 4%;
  color: #757575;
}

/* Styles pour le lecteur vidéo */
.video-player-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: black;
  z-index: 2000;
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 1;
  transition: opacity 0.3s ease;
}

.video-player-modal.show {
  opacity: 1;
}

.video-container {
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: black;
}

.video-player {
  width: 100%;
  height: 100%;
  object-fit: contain;
  position: absolute;
  top: 0;
  left: 0;
  z-index: 5;
  background-color: black;
}

/* Animation du clic sur la vidéo */
.video-click-animation {
  position: absolute;
  width: 160px;
  height: 160px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.25);
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transform: scale(0.5);
  z-index: 6;
  pointer-events: none;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.video-click-animation svg {
  width: 80px;
  height: 80px;
  color: white;
  filter: drop-shadow(0 0 8px rgba(0, 0, 0, 0.5));
}

.video-click-animation.show {
  animation: click-ripple 0.8s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes click-ripple {
  0% {
    opacity: 1;
    transform: scale(0.5);
    background-color: rgba(255, 255, 255, 0.35);
  }
  50% {
    opacity: 0.8;
    transform: scale(1.2);
    background-color: rgba(255, 255, 255, 0.25);
  }
  100% {
    opacity: 0;
    transform: scale(2);
    background-color: rgba(255, 255, 255, 0);
  }
}

/* Masquer les contrôles natifs de la vidéo */
.video-player::-webkit-media-controls {
  display: none !important;
}

.video-player::-webkit-media-controls-enclosure {
  display: none !important;
}

.video-player::-webkit-media-controls-panel {
  display: none !important;
}

/* Contrôles personnalisés */
.video-controls {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));
  padding: 20px;
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 10;
  pointer-events: auto;
}

.video-container:hover .video-controls {
  opacity: 1;
}

.controls-wrapper {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  gap: 15px;
  width: 100%;
}

.video-progress {
  flex-grow: 1;
  height: 4px;
  background: rgba(255, 255, 255, 0.3);
  position: relative;
  cursor: pointer;
  border-radius: 2px;
  transition: height 0.2s ease;
}

.video-progress:hover {
  height: 6px;
}

.video-progress-filled {
  background: #e50914;
  height: 100%;
  border-radius: 2px;
  position: relative;
  transition: transform 0.1s ease;
}

.video-progress-filled::after {
  content: "";
  position: absolute;
  right: -6px;
  top: 50%;
  transform: translateY(-50%);
  width: 12px;
  height: 12px;
  background: #e50914;
  border-radius: 50%;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.video-progress:hover .video-progress-filled::after {
  opacity: 1;
}

.video-control-button {
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  padding: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.85;
  transition: opacity 0.2s ease;
}

.video-control-button:hover {
  opacity: 1;
}

.video-control-button svg {
  width: 28px;
  height: 28px;
}

.time-display {
  color: white;
  font-size: 14px;
  min-width: 100px;
  font-family: "Poppins", sans-serif;
  opacity: 0.9;
}

/* Overlay pour le titre du film */
.video-title-overlay {
  position: absolute;
  top: 20px;
  left: 0;
  right: 0;
  padding: 20px;
  background: linear-gradient(rgba(0, 0, 0, 0.9), transparent);
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 6;
  pointer-events: none;
}

.video-container:hover .video-title-overlay {
  opacity: 1;
}

.video-title {
  color: white;
  font-size: 1.5rem;
  font-weight: 500;
  margin: 0;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 20px;
}

/* Bouton de fermeture amélioré */
.video-close {
  position: absolute;
  top: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.6);
  border: none;
  color: white;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  transition: all 0.3s ease;
  z-index: 11;
  opacity: 0;
}

.video-container:hover .video-close {
  opacity: 1;
}

.video-close:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.1);
}

/* Animation de chargement */
.loading-spinner {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 50px;
  height: 50px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: #e50914;
  animation: spin 1s linear infinite;
  display: none;
}

.video-player.loading + .loading-spinner {
  display: block;
}

@keyframes spin {
  to {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}

@keyframes check-animation {
  0% {
    transform: scale(0);
    opacity: 0;
  }
  50% {
    transform: scale(1.5);
    opacity: 1;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

/* Volume control */
.volume-control {
  position: relative;
  display: flex;
  align-items: center;
  gap: 10px;
}

.volume-slider-container {
  width: 0;
  overflow: hidden;
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
}

.volume-control:hover .volume-slider-container {
  width: 100px;
}

.volume-slider {
  width: 80px;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(255, 255, 255, 0.3);
  outline: none;
  border-radius: 2px;
  transition: height 0.2s ease;
}

.volume-slider:hover {
  height: 6px;
}

.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px;
  height: 12px;
  background: #e50914;
  border-radius: 50%;
  cursor: pointer;
  transition: transform 0.2s ease;
}

.volume-slider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
}

.volume-slider::-moz-range-thumb {
  width: 12px;
  height: 12px;
  background: #e50914;
  border-radius: 50%;
  cursor: pointer;
  border: none;
  transition: transform 0.2s ease;
}

.volume-slider::-moz-range-thumb:hover {
  transform: scale(1.2);
}

/* Responsive Design */
@media (max-width: 768px) {
  .nav-links {
    display: none;
  }

  .featured-content h2 {
    font-size: 2rem;
  }

  .description {
    font-size: 1rem;
  }

  .buttons {
    flex-direction: column;
  }

  .modal-content {
    width: 100%;
    margin: 0;
    border-radius: 0;
    min-height: 100vh;
  }

  .modal-backdrop {
    height: 300px;
  }

  .modal-header h2 {
    font-size: 2rem;
  }

  .cast-list {
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  }

  .recommendations-list {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  }

  .modal-info {
    padding: 20px;
  }

  .star {
    font-size: 18px;
  }

  .overview {
    font-size: 1rem;
  }
}

/* Styles pour la barre de défilement personnalisée */
.movie-modal::-webkit-scrollbar {
  width: 8px;
}

.movie-modal::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
}

.movie-modal::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

.movie-modal::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Message lorsque la liste est vide */
.empty-list {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 4rem 2rem;
  min-height: 300px;
  margin: 2rem auto;
  max-width: 600px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  color: #ccc;
}

/* Style pour le message "Continuer à regarder" vide */
.empty-continue {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 2rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  color: #ccc;
  margin: 1rem 0;
}

.empty-continue p {
  margin: 0.5rem 0;
  line-height: 1.5;
  font-size: 1.1rem;
}

.empty-continue p:first-child {
  color: #fff;
  font-weight: 500;
}

/* Styles pour les sections avec un seul film */
.movie-row.single-movie {
  justify-content: center;
}

.movie-row.single-movie .movie-card {
  min-width: 300px;
  max-width: 400px;
}

/* Message quand aucun résultat local n'est trouvé */
.no-results {
  text-align: center;
  padding: 2rem;
  color: #ccc;
  font-size: 1.1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  margin: 1rem 0;
}

/* Styles pour l'image placeholder */
.movie-card img[src*="placeholder"] {
  background: linear-gradient(45deg, #2a2a2a, #404040);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 500;
}
</style>

    <script>
      // Configuration TMDB
const CONFIG = {
  API_KEY: "91ced4ce6622e9a719480bc7b9d0f0ab", // A remplacer par une approche plus sécurisée (backend ou variables d'environnement)
  API_BASE_URL: "https://api.themoviedb.org/3",
  IMAGE_BASE_URL: "https://image.tmdb.org/t/p",
  POSTER_SIZE: "w500",
  BACKDROP_SIZE: "original",
  LANGUAGE: "fr-FR",
  REGION: "FR",
  DEFAULT_PARAMS: "include_adult=false&include_video=true",

  // Paramètres de mise en cache (nouveau)
  CACHE_DURATION: 60 * 5, // 5 minutes en secondes
};

// Instance du service TMDB
const tmdbService = new TMDBService();

// État local pour stocker les films
let movies = {
  trending: [],
  popular: [],
  continue: [], // Cette partie sera gérée localement avec localStorage
};

// Fonction pour créer une carte de film
function createMovieCard(movie) {
  const card = document.createElement("div");
  card.className = "movie-card";

  const posterPath = movie.poster_path || movie.backdrop_path;
  const imageUrl = tmdbService.getImageUrl(posterPath, CONFIG.POSTER_SIZE);

  card.innerHTML = `
        <img src="${imageUrl}" alt="${movie.title}" loading="lazy">
        <div class="movie-info">
            <h4>${movie.title}</h4>
            ${
              movie.progress
                ? `<div class="progress-bar"><div style="width: ${movie.progress}%"></div></div>`
                : ""
            }
            <div class="movie-overview">
                <p>${truncateText(movie.overview, 100)}</p>
            </div>
        </div>
    `;

  // Ajouter un gestionnaire d'événements pour afficher les détails
  card.addEventListener("click", () => showMovieDetails(movie.id));

  return card;
}

// Fonction pour extraire l'ID YouTube de l'URL
function getYoutubeEmbedUrl(trailerUrl) {
  if (!trailerUrl) return null;
  const videoId = trailerUrl.split("v=")[1];
  return videoId
    ? `https://www.youtube-nocookie.com/embed/${videoId}?autoplay=1&rel=0`
    : null;
}

// Fonction pour générer les étoiles de notation
function generateStarRating(rating) {
  const starTotal = 5;
  const starPercentage = (rating / 10) * starTotal;
  const fullStars = Math.floor(starPercentage);
  const hasHalfStar = starPercentage - fullStars >= 0.5;
  const emptyStars = starTotal - fullStars - (hasHalfStar ? 1 : 0);

  const stars = [];

  // Étoiles pleines
  for (let i = 0; i < fullStars; i++) {
    stars.push('<span class="star full">★</span>');
  }

  // Demi-étoile
  if (hasHalfStar) {
    stars.push('<span class="star half">★</span>');
  }

  // Étoiles vides
  for (let i = 0; i < emptyStars; i++) {
    stars.push('<span class="star empty">★</span>');
  }

  return `
        <div class="star-rating" title="${rating.toFixed(1)}/10">
            <div class="stars">${stars.join("")}</div>
            <div class="rating-number">${rating.toFixed(1)}</div>
        </div>
    `;
}

// Fonction pour afficher les détails d'un film
async function showMovieDetails(movieId) {
  // D'abord essayer de trouver le film dans les films locaux
  const localMovies = await tmdbService.getLocalMovies();
  let movie = localMovies.find((m) => m.id === movieId);

  // Si le film n'est pas trouvé localement, essayer avec l'API TMDB
  if (!movie) {
    movie = await tmdbService.getMovieDetails(movieId);
  }

  if (!movie) return;

  // Pour les films locaux, utiliser les données par défaut
  const trailerUrl = movie.trailerUrl || null; // Les films locaux n'ont pas de bande-annonce pour l'instant
  const embedUrl = getYoutubeEmbedUrl(trailerUrl);

  // Pour les films locaux, pas besoin de charger les crédits et recommandations depuis TMDB
  let credits = null;
  let recommendations = [];

  // Si ce n'est pas un film local, charger les données TMDB
  if (!localMovies.find((m) => m.id === movieId)) {
    credits = await tmdbService.getMovieCredits(movieId);
    recommendations = await tmdbService.getMovieRecommendations(movieId);
  }

  const isInList = tmdbService.isInMyList(movieId);

  const modal = document.createElement("div");
  modal.className = "movie-modal";

  const formattedDate = formatDate(movie.release_date);

  // Préparer les éléments HTML pour les actions
  const playButtonHTML = `
    <button class="action-button play-button" data-movie-id="${movie.id}">
      <svg viewBox="0 0 24 24">
        <path d="M8 5v14l11-7z" fill="currentColor" />
      </svg>
      Lecture
    </button>
  `;

  const listButtonHTML = `
    <button class="action-button list-button ${
      isInList ? "in-list" : ""
    }" data-movie-id="${movie.id}">
      <svg viewBox="0 0 24 24">
        <path d="${
          isInList
            ? "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
            : "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
        }" fill="currentColor" />
      </svg>
      ${isInList ? "Dans ma liste" : "Ma Liste"}
    </button>
  `;

  modal.innerHTML = `
    <div class="modal-content">
      ${
        embedUrl
          ? `<div class="modal-video-container">
              <iframe src="${embedUrl}" frameborder="0" allowfullscreen></iframe>
            </div>`
          : `<div class="modal-backdrop" style="background-image: url('${
              movie.backdrop_path
                ? tmdbService.getImageUrl(movie.backdrop_path)
                : "https://via.placeholder.com/1920x1080/1a1a1a/ffffff?text=" +
                  encodeURIComponent(movie.title)
            }')">
              <div class="backdrop-overlay"></div>
            </div>`
      }

      <div class="modal-info">
        <button class="modal-close">&times;</button>

        <div class="modal-header">
          <h2>${movie.title}</h2>
          
          <div class="movie-meta">
            <div class="rating-container">
              ${generateStarRating(movie.vote_average)}
            </div>
            <span class="meta-item">${formattedDate}</span>
            <span class="meta-item">${Math.floor(movie.runtime / 60)}h ${
    movie.runtime % 60
  }min</span>
            ${
              movie.genres
                ? `
                <div class="genres">
                  ${movie.genres
                    .map(
                      (genre) => `<span class="genre-tag">${genre.name}</span>`
                    )
                    .join("")}
                </div>
              `
                : ""
            }
          </div>
          
          <div class="modal-actions">
            ${playButtonHTML}
            ${listButtonHTML}
          </div>
        </div>

        <div class="modal-body">
          <p class="overview">${movie.overview}</p>

          ${
            credits && credits.cast
              ? `
              <div class="cast-section">
                <h3>Distribution</h3>
                <div class="cast-list">
                  ${credits.cast
                    .slice(0, 6)
                    .map(
                      (actor) => `
                      <div class="cast-member">
                        <div class="cast-photo" style="background-image: url('${tmdbService.getImageUrl(
                          actor.profile_path,
                          "w185"
                        )}')"></div>
                        <div class="cast-info">
                          <span class="actor-name">${actor.name}</span>
                          <span class="character-name">${actor.character}</span>
                        </div>
                      </div>
                    `
                    )
                    .join("")}
                </div>
              </div>
            `
              : ""
          }
          
          ${
            recommendations && recommendations.length > 0
              ? `
              <div class="recommendations-section">
                <h3>Titres similaires</h3>
                <div class="recommendations-list">
                  ${recommendations
                    .slice(0, 5)
                    .map(
                      (rec) => `
                      <div class="recommendation-item" data-movie-id="${
                        rec.id
                      }">
                        <div class="recommendation-poster" style="background-image: url('${tmdbService.getImageUrl(
                          rec.poster_path,
                          "w342"
                        )}')">
                          <div class="recommendation-info">
                            <span class="rec-title">${rec.title}</span>
                            <span class="rec-rating">${generateStarRating(
                              rec.vote_average
                            )}</span>
                          </div>
                        </div>
                      </div>
                    `
                    )
                    .join("")}
                </div>
              </div>
            `
              : ""
          }
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // Gestionnaire de fermeture
  const closeModal = () => {
    modal.classList.add("closing");
    setTimeout(() => modal.remove(), 300);
  };

  modal.querySelector(".modal-close").onclick = closeModal;
  modal.onclick = (e) => {
    if (e.target === modal) closeModal();
  };

  // Gestionnaires d'événements pour les boutons
  const playButton = modal.querySelector(".play-button");
  if (playButton) {
    playButton.addEventListener("click", () => playMovie(movie));
  }

  const listButton = modal.querySelector(".list-button");
  if (listButton) {
    listButton.addEventListener("click", () => {
      const result = tmdbService.toggleMyList(movie);
      if (result.inList) {
        listButton.classList.add("in-list");
        listButton.innerHTML = `
          <svg viewBox="0 0 24 24">
            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor" />
          </svg>
          Dans ma liste
        `;
      } else {
        listButton.classList.remove("in-list");
        listButton.innerHTML = `
          <svg viewBox="0 0 24 24">
            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" fill="currentColor" />
          </svg>
          Ma Liste
        `;
      }
    });
  }

  // Gestionnaires d'événements pour les recommandations
  modal.querySelectorAll(".recommendation-item").forEach((item) => {
    const recId = parseInt(item.dataset.movieId);
    item.addEventListener("click", () => {
      closeModal();
      showMovieDetails(recId);
    });
  });

  // Animation d'ouverture
  requestAnimationFrame(() => {
    modal.classList.add("show");
  });
}

// Fonction pour remplir les rangées de films
async function populateMovieRows() {
  try {
    // Récupérer les films locaux
    const localMovies = await tmdbService.getLocalMovies();

    if (localMovies.length === 0) {
      console.warn("Aucun film local trouvé dans movies.json");
      return;
    }

    // Utiliser les films locaux pour toutes les sections
    movies.trending = localMovies;
    movies.popular = localMovies;

    // Remplir la section "Tendances actuelles"
    const trendingRow = document.querySelector(".trending .movie-row");
    trendingRow.innerHTML = "";
    localMovies.forEach((movie) => {
      trendingRow.appendChild(createMovieCard(movie));
    });

    // Remplir la section "Populaire sur HZFlix"
    const popularRow = document.querySelector(".popular .movie-row");
    popularRow.innerHTML = "";
    localMovies.forEach((movie) => {
      popularRow.appendChild(createMovieCard(movie));
    });

    // Charger les films "Continuer à regarder" avec la méthode dédiée
    const continueWatching = tmdbService.getContinueWatching();
    movies.continue = continueWatching;

    const continueWatchingSection =
      document.querySelector(".continue-watching");

    // Afficher ou masquer la section selon qu'il y a des films à continuer ou non
    if (continueWatching.length === 0) {
      // Option 1: Masquer complètement la section
      // continueWatchingSection.style.display = "none";

      // Option 2: Afficher un message
      continueWatchingSection.innerHTML = `
        <h3>Continuer à regarder</h3>
        <div class="empty-continue">
          <p>Vous n'avez pas de films en cours de visionnage.</p>
          <p>Les films que vous commencez à regarder apparaîtront ici.</p>
        </div>
      `;
    } else {
      // Afficher les films en cours de visionnage
      continueWatchingSection.innerHTML = `
        <h3>Continuer à regarder</h3>
        <div class="movie-row"></div>
      `;

      const continueRow = continueWatchingSection.querySelector(".movie-row");
      continueWatching.forEach((movie) => {
        continueRow.appendChild(createMovieCard(movie));
      });
    }

    // Mettre à jour le film à la une avec le premier film local
    if (localMovies.length > 0) {
      updateFeaturedMovie(localMovies[0]);
    }
  } catch (error) {
    console.error("Erreur lors du chargement des films:", error);
  }
}

// Fonction pour mettre à jour le film à la une
function updateFeaturedMovie(movie) {
  const featuredContent = document.querySelector(".featured-content");
  const backdropUrl = tmdbService.getImageUrl(movie.backdrop_path);

  document.querySelector(
    ".hero"
  ).style.backgroundImage = `linear-gradient(to bottom, rgba(0,0,0,0.4), rgba(0,0,0,0.8)), url('${backdropUrl}')`;
  featuredContent.querySelector("h2").textContent = movie.title;
  featuredContent.querySelector(".description").textContent = movie.overview;

  // Ajouter les gestionnaires d'événements pour les boutons
  const playButton = featuredContent.querySelector(".play-btn");
  const infoButton = featuredContent.querySelector(".info-btn");
  playButton.onclick = () => {
    playMovie(movie);
  };

  infoButton.onclick = () => {
    showMovieDetails(movie.id);
  };
}

// Effet de scroll pour le header
function handleHeaderScroll() {
  const header = document.querySelector("header");
  window.addEventListener("scroll", () => {
    if (window.scrollY > 50) {
      header.classList.add("scrolled");
    } else {
      header.classList.remove("scrolled");
    }
  });
}

// Fonction de recherche
async function handleSearch() {
  const searchInput = document.getElementById("searchInput");
  const query = searchInput.value.trim();

  if (!query) return;

  try {
    // Rechercher d'abord dans les films locaux
    const localMovies = await tmdbService.getLocalMovies();
    const localResults = localMovies.filter((movie) =>
      movie.title.toLowerCase().includes(query.toLowerCase())
    );

    // Créer une nouvelle section pour les résultats
    const mainElement = document.querySelector("main");
    let searchSection = document.querySelector(".search-results");

    if (!searchSection) {
      searchSection = document.createElement("section");
      searchSection.className = "search-results";
      mainElement.insertBefore(
        searchSection,
        mainElement.firstChild.nextSibling
      );
    }

    // Si on trouve des résultats locaux, les afficher en priorité
    if (localResults.length > 0) {
      searchSection.innerHTML = `
        <h3>Résultats de recherche pour "${query}" - Films Disponibles</h3>
        <div class="movie-row"></div>
      `;

      const movieRow = searchSection.querySelector(".movie-row");
      localResults.forEach((movie) => {
        movieRow.appendChild(createMovieCard(movie));
      });
    } else {
      // Si aucun résultat local, chercher dans TMDB (optionnel)
      const searchResults = await tmdbService.searchMovies(query);

      searchSection.innerHTML = `
        <h3>Résultats de recherche pour "${query}"</h3>
        <div class="movie-row"></div>
      `;

      const movieRow = searchSection.querySelector(".movie-row");

      // Vérifier si nous avons des résultats
      if (searchResults.length === 0) {
        movieRow.innerHTML =
          '<div class="no-results">Aucun résultat trouvé dans notre catalogue</div>';
      } else {
        searchResults.forEach((movie) => {
          movieRow.appendChild(createMovieCard(movie));
        });
      }
    }

    // Faire défiler jusqu'aux résultats
    searchSection.scrollIntoView({ behavior: "smooth" });
  } catch (error) {
    console.error("Erreur lors de la recherche:", error);
  }
}

// Gestion de la navigation
async function handleNavigation(section) {
  // Mettre à jour la classe active
  document.querySelectorAll(".nav-links a").forEach((link) => {
    link.classList.remove("active");
  });
  document
    .querySelector(`.nav-links a[data-section="${section}"]`)
    .classList.add("active");

  // Vider les sections existantes sauf le hero pour l'accueil
  const main = document.querySelector("main");
  const hero = document.querySelector(".hero");
  const searchResults = document.querySelector(".search-results");

  if (searchResults) {
    searchResults.remove();
  }

  // Masquer toutes les sections existantes
  document.querySelectorAll("main > section:not(.hero)").forEach((section) => {
    section.style.display = "none";
  });

  // Afficher/masquer le hero selon la section
  if (hero) {
    hero.style.display = section === "home" ? "flex" : "none";
  }

  try {
    switch (section) {
      case "home":
        // Afficher les sections d'accueil
        document
          .querySelectorAll(".trending, .popular, .continue-watching")
          .forEach((section) => {
            section.style.display = "block";
          });
        await populateMovieRows();
        break;
      case "series":
        // Créer et peupler la section séries
        let seriesSection = document.querySelector(".series-section");
        if (!seriesSection) {
          seriesSection = document.createElement("section");
          seriesSection.className = "series-section";
          main.appendChild(seriesSection);
        }
        seriesSection.innerHTML = `
                  <h3>Séries Populaires</h3>
                  <div class="movie-row popular-series"></div>
                  <h3>Séries les Mieux Notées</h3>
                  <div class="movie-row top-rated-series"></div>
              `;
        const popularSeriesRow = seriesSection.querySelector(
          ".movie-row.popular-series"
        );
        const topRatedSeriesRow = seriesSection.querySelector(
          ".movie-row.top-rated-series"
        );

        // Charger les séries populaires et les mieux notées en parallèle
        const [popularSeries, topRatedSeries] = await Promise.all([
          tmdbService.getPopularSeries(),
          tmdbService.getTopRatedSeries(),
        ]);

        // Afficher les séries populaires
        popularSeries.forEach((show) => {
          popularSeriesRow.appendChild(createMovieCard(show));
        });

        // Afficher les séries les mieux notées
        topRatedSeries.forEach((show) => {
          topRatedSeriesRow.appendChild(createMovieCard(show));
        });

        seriesSection.style.display = "block";
        break;
      case "movies":
        // Créer et peupler la section films avec les films locaux
        let moviesSection = document.querySelector(".movies-section");
        if (!moviesSection) {
          moviesSection = document.createElement("section");
          moviesSection.className = "movies-section";
          main.appendChild(moviesSection);
        }

        const localMovies = await tmdbService.getLocalMovies();

        moviesSection.innerHTML = `
          <h3>Films Disponibles</h3>
          <div class="movie-row local-movies"></div>
          ${
            localMovies.length > 1
              ? `
            <h3>Sélection du Moment</h3>
            <div class="movie-row featured-movies"></div>
          `
              : ""
          }
        `;

        const localMoviesRow = moviesSection.querySelector(
          ".movie-row.local-movies"
        );
        const featuredMoviesRow = moviesSection.querySelector(
          ".movie-row.featured-movies"
        );

        // Afficher tous les films locaux dans la première section
        localMovies.forEach((movie) => {
          localMoviesRow.appendChild(createMovieCard(movie));
        });

        // Si on a plusieurs films, dupliquer dans la section "Sélection du Moment"
        if (featuredMoviesRow && localMovies.length > 1) {
          localMovies.forEach((movie) => {
            featuredMoviesRow.appendChild(createMovieCard(movie));
          });
        }

        moviesSection.style.display = "block";
        break;

      case "mylist":
        // Créer et peupler la section Ma Liste
        let myListSection = document.querySelector(".mylist-section");
        if (!myListSection) {
          myListSection = document.createElement("section");
          myListSection.className = "mylist-section";
          main.appendChild(myListSection);
        }
        const myList = JSON.parse(localStorage.getItem("myList") || "[]");

        if (myList.length === 0) {
          // Afficher un message quand la liste est vide
          myListSection.innerHTML = `
            <h3>Ma Liste</h3>
            <div class="empty-list">
              <svg viewBox="0 0 24 24" width="64" height="64">
                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" fill="currentColor" />
              </svg>
              <h4>Votre liste est vide</h4>
              <p>Ajoutez des films et des séries à votre liste en cliquant sur le bouton "Ma Liste" pendant que vous parcourez le site.</p>
            </div>
          `;
        } else {
          // Afficher les films si la liste n'est pas vide
          myListSection.innerHTML = `
            <h3>Ma Liste</h3>
            <div class="movie-row"></div>
          `;
          const myListRow = myListSection.querySelector(".movie-row");
          myList.forEach((movie) => {
            myListRow.appendChild(createMovieCard(movie));
          });
        }

        myListSection.style.display = "block";
        break;
    }
  } catch (error) {
    console.error("Erreur lors du chargement de la section:", error);
  }
}

// Ajouter les écouteurs d'événements pour la recherche
document.getElementById("searchButton").addEventListener("click", handleSearch);
document.getElementById("searchInput").addEventListener("keypress", (e) => {
  if (e.key === "Enter") {
    handleSearch();
  }
});

// Fonction pour créer le lecteur vidéo
function createVideoPlayer(movieTitle, videoUrl, movie) {
  const modal = document.createElement("div");
  modal.className = "video-player-modal";

  modal.innerHTML = `
    <div class="video-container">
      <video class="video-player">
        <source src="${videoUrl}" type="video/mp4">
        Votre navigateur ne supporte pas la lecture vidéo.
      </video>
      <div class="loading-spinner"></div>
      <div class="video-title-overlay">
        <h2 class="video-title">${movieTitle}</h2>
      </div>
      <button class="video-close">&times;</button>
      <div class="video-controls">
        <div class="controls-wrapper">
          <button class="video-control-button play-pause">
            <svg viewBox="0 0 24 24">
              <path fill="currentColor" d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
            </svg>
          </button>
          <div class="time-display">0:00 / 0:00</div>
          <div class="video-progress">
            <div class="video-progress-filled"></div>
          </div>
          <div class="volume-control">
            <button class="video-control-button volume">
              <svg viewBox="0 0 24 24">
                <path fill="currentColor" d="M3,9V15H7L12,20V4L7,9H3Z"/>
              </svg>
            </button>
            <div class="volume-slider-container">
              <input type="range" class="volume-slider" min="0" max="100" value="100">
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(modal);

  // Sélectionner tous les éléments nécessaires
  const elements = {
    video: modal.querySelector(".video-player"),
    closeBtn: modal.querySelector(".video-close"),
    playPauseBtn: modal.querySelector(".play-pause"),
    loading: modal.querySelector(".loading-spinner"),
    progress: modal.querySelector(".video-progress-filled"),
    timeDisplay: modal.querySelector(".time-display"),
    progressBar: modal.querySelector(".video-progress"),
    volumeBtn: modal.querySelector(".volume"),
    volumeSlider: modal.querySelector(".volume-slider"),
  };
  // Configuration initiale du volume avec préférences sauvegardées
  const savedVolume =
    parseFloat(localStorage.getItem("videoPlayerVolume")) || 1;
  const isMuted = localStorage.getItem("videoPlayerMuted") === "true";
  let lastVolume = savedVolume;
  let videoLoaded = false;

  // Gestion du chargement de la vidéo
  elements.video.addEventListener("loadeddata", () => {
    videoLoaded = true;
    elements.loading.style.display = "none";
    playVideo(); // Démarrer la lecture automatiquement une fois chargée
  });

  // Définir la source de la vidéo après la configuration des événements
  elements.video.src = videoUrl;

  // Appliquer les paramètres sauvegardés
  elements.video.volume = savedVolume;
  elements.video.muted = isMuted;
  elements.volumeSlider.value = savedVolume * 100;

  // Fonctions de gestion du volume
  const saveVolumePreferences = () => {
    localStorage.setItem("videoPlayerVolume", elements.video.volume);
    localStorage.setItem("videoPlayerMuted", elements.video.muted);
  };

  const updateVolumeIcon = () => {
    const volume = elements.video.volume;
    let icon;
    if (elements.video.muted || volume === 0) {
      // Icône muet
      icon = `
        <path fill="currentColor" d="M3,9H7L12,4V20L7,15H3V9M16.59,12L14,9.41L15.41,8L18,10.59L20.59,8L22,9.41L19.41,12L22,14.59L20.59,16L18,13.41L15.41,16L14,14.59L16.59,12Z"/>
      `;
    } else if (volume < 0.5) {
      // Volume bas
      icon = `
        <path fill="currentColor" d="M5,9V15H9L14,20V4L9,9M18.5,12C18.5,10.23 17.5,8.71 16,7.97V16C17.5,15.29 18.5,13.76 18.5,12Z"/>
      `;
    } else {
      // Volume élevé
      icon = `
        <path fill="currentColor" d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12Z M3,9V15H7L12,20V4L7,9H3Z"/>
      `;
    }
    elements.volumeBtn.innerHTML = `<svg viewBox="0 0 24 24">${icon}</svg>`;
  };

  // Configuration des gestionnaires d'événements pour le volume
  elements.volumeBtn.onclick = () => {
    if (elements.video.muted || elements.video.volume === 0) {
      elements.video.muted = false;
      elements.video.volume = lastVolume;
      elements.volumeSlider.value = lastVolume * 100;
    } else {
      lastVolume = elements.video.volume;
      elements.video.volume = 0;
      elements.volumeSlider.value = 0;
    }
    updateVolumeIcon();
    saveVolumePreferences();
  };

  elements.volumeSlider.addEventListener("input", () => {
    const value = elements.volumeSlider.value / 100;
    elements.video.volume = value;
    elements.video.muted = value === 0;
    if (value > 0) {
      lastVolume = value;
    }
    updateVolumeIcon();
    saveVolumePreferences();
  });

  elements.video.addEventListener("volumechange", () => {
    updateVolumeIcon();
    saveVolumePreferences();
  });

  updateVolumeIcon();

  // Gestionnaires d'événements pour le lecteur vidéo
  const stopAndClosePlayer = () => {
    elements.video.pause();
    elements.video.currentTime = 0;
    elements.video.src = "";
    elements.video.load();
    modal.style.opacity = "0";
    setTimeout(() => {
      modal.remove();
      document.removeEventListener("keydown", handleKeyPress);
    }, 300);
  };

  const handleKeyPress = (e) => {
    if (e.key === "Escape") {
      stopAndClosePlayer();
    }
  };

  document.addEventListener("keydown", handleKeyPress);
  elements.closeBtn.onclick = stopAndClosePlayer;
  modal.addEventListener("click", (e) => {
    if (e.target === modal) stopAndClosePlayer();
  });
  // Gestion des erreurs de lecture
  let errorLogged = false;
  elements.video.addEventListener("error", (e) => {
    if (!errorLogged) {
      console.error("Erreur de lecture vidéo:", e.target.error);
      errorLogged = true;
      // Afficher un message à l'utilisateur
      const errorMessage = document.createElement("div");
      errorMessage.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 8px;
        color: white;
        text-align: center;
        z-index: 12;
      `;
      errorMessage.textContent =
        "Désolé, une erreur est survenue lors de la lecture de la vidéo.";
      modal.querySelector(".video-container").appendChild(errorMessage);

      // Fermer automatiquement après 3 secondes
      setTimeout(() => {
        stopAndClosePlayer();
      }, 3000);
    }
  });

  // Fermer le modal si la vidéo est terminée
  elements.video.addEventListener("ended", stopAndClosePlayer);

  let isPlaying = false;
  const playVideo = () => {
    if (!videoLoaded) {
      elements.loading.style.display = "block";
      return;
    }
    elements.video.play().catch((error) => {
      console.warn("Erreur lors de la lecture:", error);
      elements.loading.style.display = "none";
    });
    isPlaying = true;
    elements.playPauseBtn.innerHTML = `
      <svg viewBox="0 0 24 24">
        <path fill="currentColor" d="M6,19h4V5H6V19M14,5v14h4V5H14z"/>
      </svg>`;
  };

  const pauseVideo = () => {
    elements.video.pause();
    isPlaying = false;
    elements.playPauseBtn.innerHTML = `
      <svg viewBox="0 0 24 24">
        <path fill="currentColor" d="M8,5.14V19.14L19,12.14L8,5.14Z"/>
      </svg>`;
  };

  elements.playPauseBtn.onclick = () => {
    if (isPlaying) {
      pauseVideo();
    } else {
      playVideo();
    }
  };

  // Gestion de la barre de progression
  elements.progressBar.addEventListener("click", (e) => {
    const rect = elements.progressBar.getBoundingClientRect();
    const pos = (e.clientX - rect.left) / rect.width;
    elements.video.currentTime = pos * elements.video.duration;
  });

  let isDragging = false;

  elements.progressBar.addEventListener("mousedown", (e) => {
    isDragging = true;
    updateProgress(e);
  });

  document.addEventListener("mousemove", (e) => {
    if (isDragging) {
      updateProgress(e);
    }
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
  });

  const updateProgress = (e) => {
    const rect = elements.progressBar.getBoundingClientRect();
    const pos = Math.min(Math.max(0, (e.clientX - rect.left) / rect.width), 1);
    elements.video.currentTime = pos * elements.video.duration;
  };

  // Mettre à jour l'affichage du temps
  elements.video.addEventListener("timeupdate", () => {
    const currentTime = elements.video.currentTime;
    const duration = elements.video.duration;
    elements.timeDisplay.textContent = `${formatTime(
      currentTime
    )} / ${formatTime(duration)}`;
    const percentage = (currentTime / duration) * 100;
    elements.progress.style.width = `${percentage}%`;
  });

  const formatTime = (seconds) => {
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${minutes}:${secs < 10 ? "0" + secs : secs}`;
  };

  elements.video.ontimeupdate = updateTimeDisplay;

  // Mettre à jour l'affichage du temps et la barre de progression
  function updateTimeDisplay() {
    const currentTime = elements.video.currentTime;
    const duration = elements.video.duration;
    elements.timeDisplay.textContent = `${formatTime(
      currentTime
    )} / ${formatTime(duration)}`;
    const percentage = (currentTime / duration) * 100;
    elements.progress.style.width = `${percentage}%`;
  }
  // Gestion du clic sur la vidéo
  elements.video.addEventListener("click", (e) => {
    // Vérifier que c'est un vrai clic utilisateur
    if (e.isTrusted) {
      // Créer l'élément d'animation
      const clickAnimation = document.createElement("div");
      clickAnimation.className = "video-click-animation";

      // Ajouter l'icône appropriée avec une taille plus grande
      const icon = isPlaying
        ? '<svg viewBox="0 0 24 24" style="width: 80px; height: 80px;"><path fill="currentColor" d="M6,19h4V5H6V19M14,5v14h4V5H14z"/></svg>'
        : '<svg viewBox="0 0 24 24" style="width: 80px; height: 80px;"><path fill="currentColor" d="M8,5.14V19.14L19,12.14L8,5.14Z"/></svg>';

      clickAnimation.innerHTML = icon;

      // Positionner l'animation là où l'utilisateur a cliqué
      clickAnimation.style.left = `${e.clientX - 80}px`;
      clickAnimation.style.top = `${e.clientY - 80}px`;

      // Ajouter l'animation au conteneur
      modal.querySelector(".video-container").appendChild(clickAnimation);

      // Déclencher l'animation
      requestAnimationFrame(() => {
        clickAnimation.classList.add("show");
      });

      // Supprimer l'élément après l'animation
      setTimeout(() => {
        clickAnimation.remove();
      }, 800);

      togglePlayPause();
    }
  });

  // Lecture automatique sur mobile
  const togglePlayPause = () => {
    if (isPlaying) {
      pauseVideo();
    } else {
      playVideo();
    }
  };

  // Sauvegarder la progression régulièrement
  let currentMovieData = null;

  // Récupérer les données du film associées à cette vidéo
  tmdbService
    .getMovieDetails(movie.id || movie)
    .then((movieData) => {
      currentMovieData = movieData;
    })
    .catch((error) => {
      console.error(
        "Erreur lors de la récupération des détails du film:",
        error
      );
      // Si on ne peut pas obtenir les détails, utiliser les données de base
      currentMovieData =
        typeof movie === "object" ? movie : { id: movie, title: movieTitle };
    });

  // Suivre la progression de la vidéo
  elements.video.addEventListener("timeupdate", () => {
    if (!currentMovieData) return;

    const progress =
      (elements.video.currentTime / elements.video.duration) * 100;
    if (!isNaN(progress) && progress > 0 && progress < 98) {
      // Sauvegarder la progression toutes les 5 secondes
      if (Math.floor(elements.video.currentTime) % 5 === 0) {
        tmdbService.saveMovieProgress(currentMovieData, Math.round(progress));
      }
    }
  });

  // Sauvegarder la progression quand la vidéo est fermée
  const saveProgressOnExit = () => {
    if (currentMovieData && elements.video.duration > 0) {
      const progress =
        (elements.video.currentTime / elements.video.duration) * 100;
      if (!isNaN(progress) && progress > 0 && progress < 98) {
        tmdbService.saveMovieProgress(currentMovieData, Math.round(progress));
      }
    }
  };

  // Ajout de l'événement de sauvegarde à la fermeture
  modal
    .querySelector(".video-close")
    .addEventListener("click", saveProgressOnExit);
  modal.addEventListener("click", (e) => {
    if (e.target === modal) saveProgressOnExit();
  });

  // Quand la vidéo est terminée (plus de 98% visionnée), la retirer de "continuer à regarder"
  elements.video.addEventListener("ended", () => {
    if (currentMovieData) {
      tmdbService.saveMovieProgress(currentMovieData, 100);
      // Rafraîchir la section "Continuer à regarder" si nécessaire
      const continueWatchingSection =
        document.querySelector(".continue-watching");
      if (
        continueWatchingSection &&
        continueWatchingSection.style.display !== "none"
      ) {
        populateMovieRows();
      }
    }
  });
}

// Fonction pour lire un film
async function playMovie(movie) {
  try {
    const loadingMessage = document.createElement("div");
    loadingMessage.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 8px;
      color: white;
      text-align: center;
      z-index: 1000;
    `;
    loadingMessage.textContent = "Chargement de la vidéo...";
    document.body.appendChild(loadingMessage);

    const videoUrl = await tmdbService.getMovieVideoUrl(movie.id);
    loadingMessage.remove();

    if (videoUrl && typeof videoUrl === "string" && videoUrl.trim() !== "") {
      createVideoPlayer(movie.title, videoUrl, movie);

      // Marquer que l'utilisateur a commencé à regarder ce film
      if (!movie.progress) {
        tmdbService.saveMovieProgress(movie, 0);
        // Rafraîchir la section "Continuer à regarder" si elle est visible
        const continueWatchingSection =
          document.querySelector(".continue-watching");
        if (
          continueWatchingSection &&
          continueWatchingSection.style.display !== "none"
        ) {
          setTimeout(() => populateMovieRows(), 500);
        }
      }
    } else {
      console.warn("Aucune URL de vidéo valide trouvée pour ce film.");
      const errorMessage = document.createElement("div");
      errorMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 8px;
        color: white;
        text-align: center;
        z-index: 1000;
      `;
      errorMessage.textContent =
        "Désolé, la vidéo n'est pas disponible pour le moment.";
      document.body.appendChild(errorMessage);
      setTimeout(() => {
        errorMessage.remove();
      }, 3000);
    }
  } catch (error) {
    console.error("Erreur lors du chargement de la vidéo:", error);
    const errorMessage = document.createElement("div");
    errorMessage.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 8px;
      color: white;
      text-align: center;
      z-index: 1000;
    `;
    errorMessage.textContent =
      "Erreur lors du chargement de la vidéo. Veuillez réessayer plus tard.";
    document.body.appendChild(errorMessage);
    setTimeout(() => {
      errorMessage.remove();
    }, 3000);
  }
}

// Initialiser l'application
async function init() {
  handleHeaderScroll();
  await populateMovieRows();

  // Initialiser les écouteurs d'événements de recherche avec debounce
  const searchInput = document.getElementById("searchInput");
  const searchButton = document.getElementById("searchButton");

  // Utiliser debounce pour éviter trop d'appels API pendant la frappe
  searchInput.addEventListener("input", debounce(handleSearch, 500));
  searchButton.addEventListener("click", handleSearch);

  // Écouteur d'événements pour la navigation
  document.querySelectorAll(".nav-links a").forEach((link) => {
    link.addEventListener("click", (e) => {
      e.preventDefault();
      const section = link.dataset.section;
      handleNavigation(section);
    });
  });
}

// Démarrer l'application
init();

// Service pour gérer les appels API TMDB
class TMDBService {
  constructor() {
    this.config = CONFIG;
    this.cache = {};
  }

  // Nouvelle méthode pour gérer le cache
  async fetchWithCache(
    url,
    cacheKey,
    cacheDuration = this.config.CACHE_DURATION
  ) {
    const now = Math.floor(Date.now() / 1000); // Temps actuel en secondes

    // Vérifier si nous avons une donnée en cache et si elle est encore valide
    if (this.cache[cacheKey] && now < this.cache[cacheKey].expiry) {
      return this.cache[cacheKey].data;
    }

    // Sinon, effectuer la requête
    try {
      const response = await fetch(url);
      const data = await response.json();

      // Mettre en cache avec une date d'expiration
      this.cache[cacheKey] = {
        data: data,
        expiry: now + cacheDuration,
      };

      return data;
    } catch (error) {
      console.error(`Erreur lors de la requête ${url}:`, error);
      throw error;
    }
  }

  // Récupérer les films tendance
  async getTrendingMovies() {
    try {
      const url = `${this.config.API_BASE_URL}/trending/movie/week?api_key=${this.config.API_KEY}&language=fr-FR`;
      const data = await this.fetchWithCache(url, "trending-movies");
      return data.results;
    } catch (error) {
      console.error(
        "Erreur lors de la récupération des films tendance:",
        error
      );
      return [];
    }
  }

  // Récupérer les films populaires
  async getPopularMovies() {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/movie/popular?api_key=${this.config.API_KEY}&language=fr-FR`
      );
      const data = await response.json();
      return data.results;
    } catch (error) {
      console.error(
        "Erreur lors de la récupération des films populaires:",
        error
      );
      return [];
    }
  }

  // Récupérer les détails d'un film
  async getMovieDetails(movieId) {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/movie/${movieId}?api_key=${this.config.API_KEY}&language=fr-FR&append_to_response=videos`
      );
      const data = await response.json();
      return data;
    } catch (error) {
      console.error(
        "Erreur lors de la récupération des détails du film:",
        error
      );
      return null;
    }
  }

  // Obtenir l'URL complète d'une image
  getImageUrl(path, size = "original") {
    if (!path) return "assets/placeholder.jpg";
    return `${this.config.IMAGE_BASE_URL}/${size}${path}`;
  }

  // Obtenir l'URL de la bande-annonce YouTube
  getTrailerUrl(videos) {
    if (!videos || !videos.results) return null;
    const trailer = videos.results.find(
      (video) => video.type === "Trailer" && video.site === "YouTube"
    );
    return trailer ? `https://www.youtube.com/watch?v=${trailer.key}` : null;
  }

  // Rechercher des films
  async searchMovies(query) {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/search/movie?api_key=${
          this.config.API_KEY
        }&language=${this.config.LANGUAGE}&query=${encodeURIComponent(query)}&${
          this.config.DEFAULT_PARAMS
        }`
      );
      const data = await response.json();
      return data.results;
    } catch (error) {
      console.error("Erreur lors de la recherche de films:", error);
      return [];
    }
  }

  // Obtenir les recommandations pour un film
  async getMovieRecommendations(movieId) {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/movie/${movieId}/recommendations?api_key=${this.config.API_KEY}&language=${this.config.LANGUAGE}&${this.config.DEFAULT_PARAMS}`
      );
      const data = await response.json();
      return data.results;
    } catch (error) {
      console.error(
        "Erreur lors de la récupération des recommandations:",
        error
      );
      return [];
    }
  }

  // Obtenir le casting d'un film
  async getMovieCredits(movieId) {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/movie/${movieId}/credits?api_key=${this.config.API_KEY}&language=${this.config.LANGUAGE}`
      );
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Erreur lors de la récupération du casting:", error);
      return null;
    }
  }

  // Fonction helper pour lire depuis localStorage avec gestion d'erreurs
  _getFromLocalStorage(key, defaultValue = []) {
    try {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : defaultValue;
    } catch (error) {
      console.error(
        `Erreur lors de la lecture de ${key} dans localStorage:`,
        error
      );
      return defaultValue;
    }
  }

  // Fonction helper pour écrire dans localStorage avec gestion d'erreurs
  _setLocalStorage(key, data) {
    try {
      localStorage.setItem(key, JSON.stringify(data));
    } catch (error) {
      console.error(
        `Erreur lors de l'écriture de ${key} dans localStorage:`,
        error
      );
    }
  }
  // Sauvegarder la progression d'un film
  saveMovieProgress(movie, progress) {
    try {
      let continueWatching = this._getFromLocalStorage("continueWatching");
      const existingIndex = continueWatching.findIndex(
        (m) => m.id === movie.id
      );

      // Si un film est terminé (progress >= 98), le retirer de "continuer à regarder"
      if (progress >= 98) {
        if (existingIndex !== -1) {
          continueWatching.splice(existingIndex, 1);
        }
      } else {
        const movieWithProgress = {
          ...movie,
          progress: progress,
          lastWatched: Date.now(), // Ajout d'un timestamp pour trier par date récente
        };

        if (existingIndex !== -1) {
          continueWatching[existingIndex] = movieWithProgress;
        } else {
          continueWatching.unshift(movieWithProgress);
          // Garder seulement les 10 derniers films
          continueWatching = continueWatching.slice(0, 10);
        }
      }

      this._setLocalStorage("continueWatching", continueWatching);
      return continueWatching;
    } catch (error) {
      console.error("Erreur lors de la sauvegarde de la progression:", error);
      return [];
    }
  }

  // Gestion de Ma Liste
  toggleMyList(movie) {
    try {
      const myList = this._getFromLocalStorage("myList");
      const existingIndex = myList.findIndex((m) => m.id === movie.id);

      if (existingIndex !== -1) {
        // Retirer de la liste
        myList.splice(existingIndex, 1);
        this._setLocalStorage("myList", myList);
        return { inList: false, list: myList };
      } else {
        // Ajouter à la liste
        myList.unshift(movie);
        this._setLocalStorage("myList", myList);
        return { inList: true, list: myList };
      }
    } catch (error) {
      console.error("Erreur lors de la gestion de Ma Liste:", error);
      return { inList: false, list: [] };
    }
  }

  // Vérifier si un film est dans Ma Liste
  isInMyList(movieId) {
    const myList = this._getFromLocalStorage("myList");
    return myList.some((m) => m.id === movieId);
  }

  // Récupérer les films à continuer
  getContinueWatching() {
    return this._getFromLocalStorage("continueWatching").sort(
      (a, b) => (b.lastWatched || 0) - (a.lastWatched || 0)
    );
  }

  // Récupérer Ma Liste
  getMyList() {
    return this._getFromLocalStorage("myList");
  }

  // Obtenir les genres de films
  async getMovieGenres() {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/genre/movie/list?api_key=${this.config.API_KEY}&language=${this.config.LANGUAGE}`
      );
      const data = await response.json();
      return data.genres;
    } catch (error) {
      console.error("Erreur lors de la récupération des genres:", error);
      return [];
    }
  }

  // Obtenir les séries populaires
  async getPopularSeries() {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/tv/popular?api_key=${this.config.API_KEY}&language=${this.config.LANGUAGE}&${this.config.DEFAULT_PARAMS}`
      );
      const data = await response.json();
      // Adapter le format des séries pour correspondre au format des films
      return data.results.map((show) => ({
        ...show,
        title: show.name,
        release_date: show.first_air_date,
      }));
    } catch (error) {
      console.error(
        "Erreur lors de la récupération des séries populaires:",
        error
      );
      return [];
    }
  } // Obtenir l'URL de la vidéo d'un film depuis notre fichier JSON local
  async getMovieVideoUrl(movieId) {
    try {
      const response = await fetch("/assets/movies.json");
      if (!response.ok) {
        throw new Error("Impossible de charger le fichier movies.json");
      }
      const data = await response.json();

      // Chercher le film spécifique par ID
      const movie = data.movies.find((m) => m.id === movieId);
      if (movie && movie.videoUrl) {
        return movie.videoUrl;
      }

      // Fallback: retourner la première vidéo disponible si l'ID n'est pas trouvé
      if (data.movies && data.movies.length > 0) {
        return data.movies[0].videoUrl;
      }
      return null;
    } catch (error) {
      console.error("Erreur lors du chargement de la vidéo:", error);
      return null;
    }
  }
  // Obtenir les films les mieux notés
  async getTopRatedMovies() {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/movie/top_rated?api_key=${this.config.API_KEY}&language=${this.config.LANGUAGE}&${this.config.DEFAULT_PARAMS}`
      );
      const data = await response.json();
      return data.results;
    } catch (error) {
      console.error(
        "Erreur lors de la récupération des films les mieux notés:",
        error
      );
      return [];
    }
  }

  // Obtenir les séries les mieux notées
  async getTopRatedSeries() {
    try {
      const response = await fetch(
        `${this.config.API_BASE_URL}/tv/top_rated?api_key=${this.config.API_KEY}&language=${this.config.LANGUAGE}&${this.config.DEFAULT_PARAMS}`
      );
      const data = await response.json();
      // Adapter le format des séries pour correspondre au format des films
      return data.results.map((show) => ({
        ...show,
        title: show.name,
        release_date: show.first_air_date,
      }));
    } catch (error) {
      console.error(
        "Erreur lors de la récupération des séries les mieux notées:",
        error
      );
      return [];
    }
  }
  // Nouvelle méthode pour charger les films locaux
  async getLocalMovies() {
    try {
      const response = await fetch("/assets/movies.json");
      if (!response.ok) {
        throw new Error("Impossible de charger le fichier movies.json");
      }
      const data = await response.json();

      // Pour chaque film local, rechercher ses informations via TMDB
      const moviesWithDetails = await Promise.all(
        data.movies.map(async (localMovie) => {
          try {
            // Rechercher le film par titre sur TMDB
            const searchResults = await this.searchMovies(localMovie.title);

            if (searchResults && searchResults.length > 0) {
              // Prendre le premier résultat qui correspond le mieux
              const tmdbMovie = searchResults[0];

              // Récupérer les détails complets du film
              const movieDetails = await this.getMovieDetails(tmdbMovie.id);

              if (movieDetails) {
                // Combiner les données TMDB avec l'URL vidéo locale
                return {
                  ...movieDetails,
                  // Créer un ID unique pour le film local
                  id: `local-${tmdbMovie.id}`,
                  originalTmdbId: tmdbMovie.id,
                  videoUrl: localMovie.videoUrl,
                  // Marquer comme film local
                  isLocal: true,
                };
              }
            }

            // Si aucun résultat TMDB trouvé, créer une entrée basique
            return {
              id: `local-${Date.now()}-${Math.random()
                .toString(36)
                .substr(2, 9)}`,
              title: localMovie.title,
              videoUrl: localMovie.videoUrl,
              overview: `${localMovie.title} - Film disponible en streaming sur HZFlix`,
              poster_path: null,
              backdrop_path: null,
              release_date: "2024",
              vote_average: 8.0,
              runtime: 120,
              genres: [
                { id: 28, name: "Action" },
                { id: 12, name: "Aventure" },
              ],
              isLocal: true,
            };
          } catch (error) {
            console.error(
              `Erreur lors de la recherche de "${localMovie.title}":`,
              error
            );

            // Retourner une entrée basique en cas d'erreur
            return {
              id: `local-${Date.now()}-${Math.random()
                .toString(36)
                .substr(2, 9)}`,
              title: localMovie.title,
              videoUrl: localMovie.videoUrl,
              overview: `${localMovie.title} - Film disponible en streaming sur HZFlix`,
              poster_path: null,
              backdrop_path: null,
              release_date: "2024",
              vote_average: 8.0,
              runtime: 120,
              genres: [
                { id: 28, name: "Action" },
                { id: 12, name: "Aventure" },
              ],
              isLocal: true,
            };
          }
        })
      );

      return moviesWithDetails.filter((movie) => movie !== null);
    } catch (error) {
      console.error("Erreur lors du chargement des films locaux:", error);
      return [];
    }
  }
}

// Fonction utilitaires pour HZFlix

/**
 * Applique un délai avant l'exécution d'une fonction
 * @param {Function} func - La fonction à exécuter
 * @param {number} wait - Le délai d'attente en millisecondes
 * @returns {Function} - La fonction avec debounce
 */
function debounce(func, wait = 300) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Tronque un texte à une longueur donnée et ajoute des points de suspension
 * @param {string} text - Le texte à tronquer
 * @param {number} maxLength - La longueur maximale
 * @returns {string} - Le texte tronqué
 */
function truncateText(text, maxLength = 100) {
  if (!text || text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + "...";
}

/**
 * Formatte une date au format français
 * @param {string} dateStr - La chaîne de date à formatter
 * @returns {string} - La date formattée
 */
function formatDate(dateStr) {
  if (!dateStr) return "";
  return new Date(dateStr).toLocaleDateString("fr-FR", {
    day: "numeric",
    month: "long",
    year: "numeric",
  });
}
    </script>
  </body>
</html>




